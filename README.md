Алгоритм - набор действий для пошагового решения проблемы
Wiki [Algorithm](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC#.D0.9C.D0.B0.D1.88.D0.B8.D0.BD.D0.B0_.D0.A2.D1.8C.D1.8E.D1.80.D0.B8.D0.BD.D0.B3.D0.B0) 

 "Hello World" на языке Си

```C
#include <stdio.h>
int main(void) {
  printf("Hello World\n");
  return 0;
}
```

Программы в Cи состоят из функций, а те — из операторов и переменных. **Функция** — это кусок кода, в котором уже есть или подаются какие-то данные, а какие-то данные получаются в результате её исполнения. 

`printf()` из стандартной библиотеки `stdio` выводит любую строку на экран. Строки заключаются в двойные кавычки, а символ `\n` означает перевод курсора на новую строку. 

**Компилятор** - принимает на вход исходный код, и преобразует его в объектный код, т.е в 0 и 1, машинный код понятный компьютеру.

`#include <stdio.h>` - дает доступ к библиотеке функций

Строка `#include` делает очень важную вещь: она подключает библиотеки уже написанного кода к вашей программе. 

Имя подключенной библиотеки идет в угловых скобках `(<>)` и носит расширение `(.h)`. Если бы не было библиотек, то любое, самое элементарное действие, пришлось бы каждый раз описывать снова и снова. Подключенная нами библиотека содержит функции ввода/вывода. Именно она позволяет нам использовать функцию `printf()` для вывода на экран. То есть, если бы мы не написали строку `#include <stdio.h>`, но оставили в теле программы функцию `printf ()`, при попытке запуска мы бы получили ошибку! Потому что без этой библиотеки компилятор не знает, что такое `printf()`. 

Есть библиотеки стандартные, они составляют словарный запас языка. Функция `printf()` не встроена в компьютер, но входит в стандартную библиотеку языка Cи

В технических терминах, библиотека — это двоичный файл, полученный путем объединения в коллекцию объектных файлов, используя компоновщик. **Объектные файлы** — это те файлы с расширением `(*.o)`, которые вы получаете при компиляции приложений

`printf("")` - функция для печати

```bash
~/terminal$ ./hello
Hello World
```

`clang [name]` - один из компиляторов. Для компиляции можно также использовать уже знакомую вам программу `make`. По сути, она вызывает `clang` с определенными аргументами командной строки. 

`make [name]` - команда компилирует указанный файл `name`

`./a.out` - название первой скомпилированной программы по умолчанию

```bash
~/C-iazyk-proghrammirovaniia-Si$ clang hello.c
~/C-iazyk-proghrammirovaniia-Si$ ./hello
Hello World
~/C-iazyk-proghrammirovaniia-Si$ ./a.out
Hello World
```

```bash
~/terminal$ make hello
clang   hello.o   -o hello
```

```C
#include<stdio.h>

int main(void)
{
for (int i = 0; i < 10; i++)
printf("hello, world!\n");
}
```

```C
#include <stdio.h>

int main() {
int a, b, c;
    a = 5;
    b = 7;
    c = a + b;
    printf("%d + %d = %d\n", a, b, c);
    return 0;
}
```

Например, библиотека строк [string.h](https://ru.wikipedia.org/wiki/String.h), где описаны операции со строками (определение длины, сложение и прочее) 


255 в двоичной 11111111, так как начало счета с 0 и до 255 = 256 чисел

256 в двоичной 100000000

---

[**Жадный алгоритм**](https://ru.wikipedia.org/wiki/%D0%96%D0%B0%D0%B4%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC) (*Greedy algorithm*) — алгоритм, заключающийся в принятии локально [оптимальных решений](https://ru.wikipedia.org/wiki/Оптимальное_решение) на каждом этапе, допуская, что конечное решение также окажется оптимальным.

Если глобальная оптимальность алгоритма имеет место практически всегда, его обычно предпочитают другим методам оптимизации, таким как [динамическое программирование](https://ru.wikipedia.org/wiki/Динамическое_программирование).

(

**Динамическое программирование** — способ решения сложных задач путём разбиения их на более простые подзадачи. Он применим к задачам с оптимальной подструктурой, выглядящим как набор перекрывающихся подзадач, сложность которых чуть меньше исходной. В этом случае время вычислений, по сравнению с «наивными» методами, можно значительно сократить.

Ключевая идея в динамическом программировании достаточно проста. Как правило, чтобы решить поставленную задачу, требуется решить отдельные части задачи (подзадачи), после чего объединить решения подзадач в одно общее решение. Часто многие из этих подзадач одинаковы. Подход динамического программирования состоит в том, чтобы решить каждую подзадачу только один раз, сократив тем самым количество вычислений. Это особенно полезно в случаях, когда число повторяющихся подзадач экспоненциально велико.

Метод *динамического программирования сверху* — это простое запоминание результатов решения тех подзадач, которые могут повторно встретиться в дальнейшем. *Динамическое программирование снизу* включает в себя переформулирование сложной задачи в виде [рекурсивной](https://ru.wikipedia.org/wiki/Рекурсия) последовательности более простых подзадач.

)

Общего критерия оценки применимости жадного алгоритма для решения конкретной задачи не существует, однако для задач, решаемых жадными алгоритмами, характерны две особенности:

**Принцип жадного выбора** - если последовательность локально оптимальных выборов даёт глобально оптимальное решение. В типичном случае доказательство оптимальности следует такой схеме:

1. Доказывается, что жадный выбор на первом шаге не закрывает пути к оптимальному решению: для всякого решения есть другое, согласованное с жадным выбором и не хуже первого.
2. Показывается, что подзадача, возникающая после жадного выбора на первом шаге, аналогична исходной.
3. Рассуждение завершается по индукции.

**Оптимальность для подзадач** - если оптимальное решение задачи содержит в себе оптимальные решения для всех её подзадач.

### Размен монет

Так, например, сумму в 24 копейки монетами в 1, 5 и 7 коп. жадный алгоритм разменивает так: 7 коп. — 3 шт., 1 коп. — 3 шт., в то время как правильное решение — 7 коп. — 2 шт., 5 коп. — 2 шт.

Представим, что кассир должен покупателю сдачу в 41 цент, а у него на поясе есть цилиндры с монетками для сдачи номиналом в 25, 10, 5 и 1 цент. Руководствующийся «жадным» алгоритмом кассир сразу же захочет выдать максимум, на первом же шаге. На этом шаге оптимальным или наилучшим решением будет выдать 25 пенсов. 41-25 = 16. Осталось выдать 16 пенсов. Очевидно, 25 пенсов слишком много, значит, остается 10. 16-10 = 6. Теперь выдаем по тому же принципу 5 пенсов, и затем — 1. Таким образом, покупатель получит всего четыре монеты номиналом 25, 10, 5 и 1 пенс.

---

### HelloWorld на Java
```java
public class HelloWorld {
   public static void main(String[] args) {
       // Выводим Hello World в консоль.
       System.out.println("Hello, World");
   }
}
```

---

## **Brian W. Kernighan, Dennis M. Ritchie**

## **The C programming Language**, **Second Edition**

### Глава 1. Обзор языка
Программа на Си, каких бы размеров она ни была, состоит из *функций и переменных*. Функции содержат *инструкции*, описывающие вычисления, которые необходимо выполнить, а переменные хранят значения, используемые в процессе этих вычислений.

 "Hello World" на языке Си

```C
#include <stdio.h>
int main(void) {
  printf("Hello World\n");
  return 0;
}
```
Приведенная программа - это функция с именем `main`. Обычно вы вольны придумывать любые имена для своих функций, но “main" - особое имя: любая программа начинает свои вычисления с первой инструкции функции `main`.

```C
#include <stdio.h>
```
сообщает компилятору, что он должен включить информацию о стандартной библиотеке ввода-вывода. Эта строка встречается в начале многих исходных файлов Си-программ.

Один из способов передачи данных между функциями состоит в том, что функция при обращении к другой функции передает ей список значений, называемых **аргументами**. Этот список берется в скобки и помещается после имени функции. В нашем примере `main` определена как функция, которая не ждет никаких аргументов, что отмечено пустым списком (void).

```C
printf("Hello World\n");
```

Функция `main` вызывает библиотечную функцию `printf` для печати заданной последовательности символов; `\n` - символ новой строки. Символ новой строки никогда не вставляется автоматически.

Функция `printf` - это библиотечная функция, которая в данном случае напечатает последовательность символов, заключенную в двойные кавычки.

```C
#include <stdio.h>
/* печать таблицы температур по Фаренгейту
и Цельсию для fahr = 0, 20, ..., 300 */
main()
{
    int fahr, celsius;
    int lower, upper, step;

    lower = 0; /* нижняя граница таблицы температур */
    upper = 300; /* верхняя граница */
    step = 20;  /* шаг */

    fahr = lower;
    while (fahr <= upper) {
        celsius = 5 * (fahr-32) / 9;
        printf(“%d\t%d\n”, fahr, celsius);
        fahr = fahr + step;
    }
}
```
```
0	-17
20	-6
40	4
60	15
80	26
100	37
120	48
140	60
160	71
180	82
200	93
220	104
240	115
260	126
280	137
300	148
```

В Си любая переменная должна быть объявлена раньше, чем она будет использована; обычно все переменные объявляются в начале функции перед первой исполняемой инструкцией. В объявлении описываются свойства переменных. Оно состоит из названия типа и списка переменных, например:

```C
int fahr, celsius;
int lower, upper, step;
```
Тип `int` означает, что значения перечисленных переменных есть целые, в отличие от него тип `float` указывает на значения с плавающей точкой, т. е. на числа, которые могут иметь дробную часть.

Числа типа `int` бывают как 16-разрядные (лежат в диапазоне от -32768 до 32767), так и 32-разрядные. Числа типа `float` обычно представляются 32-разрядными словами, имеющими по крайней мере 6 десятичных значащих цифр (лежат приблизительно в диапазоне от 10-38 до 10+38.

Помимо `int` и `float` в Си имеется еще несколько базовых типов для данных, это:

`char` - символ-единичный байт;
`short` - короткое целое;
`long` - длинное целое;
`double` - с плавающей точкой с двойной точностью.

| Тип |	Определение |	Диапазон значений |	Размер в байтах |
| :---------: | :---------- | :---------- | :---------: |
|int |	Целые числа |	-2 147 483 648 до 2 147 483 647	|  4|
|short int |	Короткие целые числа | -32 768 до 32 767	|  2|
|float |  Дробные числа (числа с плавающей запятой)	| -2 147 483 648.0 до 2 147 483 647.0	| 4 (32 bit) |
|double |	Дробные числа двойной точности	| -9 223 372 036 854 775 808 .0 до 9 223 372 036 854 775 807.0 | 8|
|long float |	Длинные дробные числа (зависит от системы) |	-9 223 372 036 854 775 808 .0 до 9 223 372 036 854 775 807.0 | 8|
|char | Символы | ‘Q’; ‘f’; ‘:’; ‘@’ | 1|
|string | Строковые данные | строки, которые можно закодировать в 32 разрядах или меньше | 4|
|bool | Булевы выражения | true; false | 1|

Программа выполняет вычисления по формуле `°С = (5/9)(°F-32`) и печатает таблицу соответствия температур по Фаренгейту температурам по Цельсию

```
celsius = 5 * (fahr-32) / 9;
```
Причина, по которой мы сначала умножаем на 5 и затем делим на 9, а не сразу умножаем на 5/9, связана с тем, что в Си, как и во многих других языках, деление целых сопровождается **отбрасыванием**, т. е. потерей дробной части. Так как 5 и 9 - целые, отбрасывание в 5/9 дало бы нуль, и на месте температур по Цельсию были бы напечатаны нули.

**Функция printf** - это универсальная функция форматного ввода-вывода. Ее первый аргумент - строка символов, в которой каждый символ `%` соответствует одному из последующих аргументов (второму, третьему, ...), а информация, расположенная за символом `%`, указывает на вид, в котором выводится каждый из этих аргументов. Например, `%d` специфицирует выдачу аргумента в виде целого десятичного числа, и инструкция

```C
printf(“%d\t%d\n”, fahr, celsius);
```
печатает целое `fahr`, выполняет табуляцию `(\t)` и печатает целое `celsius`.

В функции `printf` каждому спецификатору первого аргумента (конструкции, начинающейся с `%`) соответствует второй аргумент, третий аргумент и т. д. Спецификаторы и соответствующие им аргументы должны быть согласованы по количеству и типам: в противном случае напечатано будет не то, что нужно.


Например, 0°F на самом деле (с точностью до десятой) равно -17.8°С, а не -17. Чтобы получить более точные значения температур, нам надо пользоваться не целочисленной арифметикой, а арифметикой с плавающей точкой.

```C
#include <stdio.h>
/* печать таблицы температур по Фаренгейту и Цельсию для fahr = 0, 20, . .., 300; вариант с плавающей точкой   */
main()
{
    float fahr, celsius;
    int lower, upper, step;

    lower = 0;   /* нижняя граница таблицы температур */ 
    upper = 300; /* верхняя граница */ 
    step = 20;   /* шаг */

    fahr = lower;
    while (fahr <= upper) { 
        celsius = (5.0/9.0) * (fahr-32.0);
        printf(“%3.0f %6.1f\n”, fahr, celsius);
        fahr = fahr + step;
    }
}
```

`printf(“%3.0f %6.1f\n”, fahr, celsius);`
Спецификация *%3.0f* в *printf* определяет печать числа с плавающей точкой (в данном случае числа *fahr*) в поле шириной не более трех позиций без десятичной точки и дробной части. Спецификация *%6.1f* описывает печать другого числа (*celsius*) в поле из шести позиций с одной цифрой после десятичной точки

```
  0  -17.8
 20   -6.7
 40    4.4
 60   15.6
 80   26.7
100   37.8
120   48.9
140   60.0
160   71.1
180   82.2
200   93.3
220  104.4
240  115.6
260  126.7
280  137.8
300  148.9
```

`%d`	- печать десятичного целого.
`%6d`	- печать десятичного целого в поле из шести позиций.
`%f`	- печать числа с плавающей точкой.
`%6f` - печать числа с плавающей точкой в поле из шести позиций.
`%.2f`	- печать числа с плавающей точкой с двумя цифрами после десятичной точки.
`%6.2f`	- печать числа с плавающей точкой и двумя цифрами после десятичной точки в поле из шести позиций.
Кроме того, printf допускает следующие спецификаторы: `%o` для восьмеричного числа; `%x` для шестнадцатеричного числа; `%c` для символа; `%s` для строки символов и `%%` для самого %.

Упражнение 1.4. Напишите программу, которая будет печатать таблицу соответствия температур по Цельсию температурам по Фаренгейту.

```C
#include <stdio.h>
main()
{
    float fahr, celsius;
    int lower, upper, step;

    lower = 0;   /* нижняя граница таблицы температур */ 
    upper = 300; /* верхняя граница */ 
    step = 20;   /* шаг */

    celsius = lower;
          printf("Таблица\n");
    while (celsius <= upper) { 
        fahr = (9.0 * celsius) / 5.0 + 32.0;
        printf("%3.0f %6.0f\n", celsius, fahr);
        celsius = celsius + step;
    }
}
```
```
Таблица 
  0     32
 20     68
 40    104
 60    140
 80    176
100    212
120    248
140    284
160    320
180    356
200    392
220    428
240    464
260    500
280    536
300    572
```







