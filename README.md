### CS50

***Алгоритм*** - набор действий для пошагового решения проблемы. Это конечная совокупность точно заданных правил решения некоторого класса задач или набор инструкций, описывающих порядок действий исполнителя для решения определённой задачи. 
Wiki [Algorithm](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC#.D0.9C.D0.B0.D1.88.D0.B8.D0.BD.D0.B0_.D0.A2.D1.8C.D1.8E.D1.80.D0.B8.D0.BD.D0.B3.D0.B0) 

***Свойства алгоритмов***

Различные определения алгоритма в явной или неявной форме содержат следующий ряд общих требований:

***Дискретность*** — алгоритм должен представлять процесс решения задачи как упорядоченное выполнение некоторых простых шагов. При этом для выполнения каждого шага алгоритма требуется конечный отрезок времени, то есть преобразование исходных данных в результат осуществляется во времени дискретно.

***Детерминированность (определённость)***. В каждый момент времени следующий шаг работы однозначно определяется состоянием системы. Таким образом, алгоритм выдаёт один и тот же результат (ответ) для одних и тех же исходных данных. С другой стороны, существуют вероятностные алгоритмы, в которых следующий шаг работы зависит от текущего состояния системы и генерируемого случайного числа. 

***Завершаемость (конечность)*** — в более узком понимании алгоритма как математической функции, при правильно заданных начальных данных алгоритм должен завершать работу и выдавать результат за определённое число шагов.

***Массовость (универсальность)***. Алгоритм должен быть применим к разным наборам начальных данных.


***Время работы***

Распространённым критерием оценки алгоритмов является время работы и порядок роста продолжительности работы в зависимости от объёма входных данных.

Для каждой конкретной задачи составляют некоторое число, которое называют её размером. Например, размером задачи вычисления произведения матриц может быть наибольший размер матриц-множителей, для задач на графах размером может быть количество ребер графа.

Время, которое тратит алгоритм как функция от размера задачи `n`, называют временной сложностью этого алгоритма `T(n)`. Асимптотику поведения этой функции при увеличении размера задачи называют асимптотичной временной сложностью, а для её обозначения используют нотацию «O» большое. 

«***O***» большое и «***o***» малое — математические обозначения для сравнения ***асимптотического поведения (асимптотики)*** функций. Под асимптотикой понимается характер изменения функции при стремлении её аргумента к определённой точке.

Например, если алгоритм обрабатывает входные данные размером `n` за время `cn²`, где `c` — некоторая константа, то говорят, что временная сложность такого алгоритма `O(n²)`. 

Асимптотическая сложность важна тем, что является характеристикой алгоритма, а не его конкретной реализации: «оптимизацией» операций, без замены алгоритма, можно изменить только мультипликативный коэффициент `c`, но не асимптотику. Aсимптотическая сложность является главным фактором, который определяет размер задач, которые алгоритм способен обработать.

<img alt="image" src="images/Нотация_Ландау.jpg"> </img>

<img alt="image" src="images/распространённые асимптотические сложности.jpg"> </img>

Алгоритм — это точно определённая инструкция, последовательно применяя которую к исходным данным, можно получить решение задачи. Например, в алгоритме деления вещественных чисел делимое может быть любым, а делитель не может быть равен нулю.

Алгоритм служит, как правило, для решения не одной конкретной задачи, а некоторого класса задач. Так, алгоритм сложения применим к любой паре натуральных чисел. В этом выражается его свойство ***массовости***, то есть возможности применять многократно один и тот же алгоритм для любой задачи одного класса.

---
"Hello World" на языке Си

```C
#include <stdio.h>
int main(void) {
  printf("Hello World\n");
  return 0;
}
```

Программы в Cи состоят из функций, а те — из операторов и переменных. **Функция** — это кусок кода, в котором уже есть или подаются какие-то данные, а какие-то данные получаются в результате её исполнения. 

`printf()` из стандартной библиотеки `stdio` выводит любую строку на экран. Строки заключаются в двойные кавычки, а символ `\n` означает перевод курсора на новую строку. 

**Компилятор** - принимает на вход исходный код, и преобразует его в объектный код, т.е в 0 и 1, машинный код понятный компьютеру.

`#include <stdio.h>` - дает доступ к библиотеке функций

Строка `#include` делает очень важную вещь: она подключает библиотеки уже написанного кода к вашей программе. 

Имя подключенной библиотеки идет в угловых скобках `(<>)` и носит расширение `(.h)`. Если бы не было библиотек, то любое, самое элементарное действие, пришлось бы каждый раз описывать снова и снова. Подключенная нами библиотека содержит функции ввода/вывода. Именно она позволяет нам использовать функцию `printf()` для вывода на экран. То есть, если бы мы не написали строку `#include <stdio.h>`, но оставили в теле программы функцию `printf ()`, при попытке запуска мы бы получили ошибку! Потому что без этой библиотеки компилятор не знает, что такое `printf()`. 

Есть библиотеки стандартные, они составляют словарный запас языка. Функция `printf()` не встроена в компьютер, но входит в стандартную библиотеку языка Cи

В технических терминах, библиотека — это двоичный файл, полученный путем объединения в коллекцию объектных файлов, используя компоновщик. **Объектные файлы** — это те файлы с расширением `(*.o)`, которые вы получаете при компиляции приложений

`printf("")` - функция для печати

```bash
$ ./hello
Hello World
```

`clang [name]` - один из компиляторов. Для компиляции можно также использовать уже знакомую вам программу `make`. По сути, она вызывает `clang` с определенными аргументами командной строки. 

`make [name]` - команда компилирует указанный файл `name`

`./a.out` - название первой скомпилированной программы по умолчанию

```bash
$ clang hello.c
$ ./hello
Hello World
$ ./a.out
Hello World
```

```bash
$ make hello
clang   hello.o   -o hello
```

```C
#include<stdio.h>

int main(void)
{
for (int i = 0; i < 10; i++)
printf("hello, world!\n");
}
```

```C
#include <stdio.h>

int main() {
int a, b, c;
    a = 5;
    b = 7;
    c = a + b;
    printf("%d + %d = %d\n", a, b, c);
    return 0;
}
```

Например, библиотека строк [string.h](https://ru.wikipedia.org/wiki/String.h), где описаны операции со строками (определение длины, сложение и прочее) 

255 в двоичной 11111111, так как начало счета с 0 и до 255 = 256 чисел

256 в двоичной 100000000

---

[**Жадный алгоритм**](https://ru.wikipedia.org/wiki/%D0%96%D0%B0%D0%B4%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC) (*Greedy algorithm*) — алгоритм, заключающийся в принятии локально [оптимальных решений](https://ru.wikipedia.org/wiki/Оптимальное_решение) на каждом этапе, допуская, что конечное решение также окажется оптимальным.

Если глобальная оптимальность алгоритма имеет место практически всегда, его обычно предпочитают другим методам оптимизации, таким как [динамическое программирование](https://ru.wikipedia.org/wiki/Динамическое_программирование).

---

**Динамическое программирование** — способ решения сложных задач путём разбиения их на более простые подзадачи. Он применим к задачам с оптимальной подструктурой, выглядящим как набор перекрывающихся подзадач, сложность которых чуть меньше исходной. В этом случае время вычислений, по сравнению с «наивными» методами, можно значительно сократить.

Ключевая идея в динамическом программировании достаточно проста. Как правило, чтобы решить поставленную задачу, требуется решить отдельные части задачи (подзадачи), после чего объединить решения подзадач в одно общее решение. Часто многие из этих подзадач одинаковы. Подход динамического программирования состоит в том, чтобы решить каждую подзадачу только один раз, сократив тем самым количество вычислений. Это особенно полезно в случаях, когда число повторяющихся подзадач экспоненциально велико.

Метод *динамического программирования сверху* — это простое запоминание результатов решения тех подзадач, которые могут повторно встретиться в дальнейшем. *Динамическое программирование снизу* включает в себя переформулирование сложной задачи в виде [рекурсивной](https://ru.wikipedia.org/wiki/Рекурсия) последовательности более простых подзадач.

---

Общего критерия оценки применимости жадного алгоритма для решения конкретной задачи не существует, однако для задач, решаемых жадными алгоритмами, характерны две особенности:

**Принцип жадного выбора** - если последовательность локально оптимальных выборов даёт глобально оптимальное решение. В типичном случае доказательство оптимальности следует такой схеме:

1. Доказывается, что жадный выбор на первом шаге не закрывает пути к оптимальному решению: для всякого решения есть другое, согласованное с жадным выбором и не хуже первого.
2. Показывается, что подзадача, возникающая после жадного выбора на первом шаге, аналогична исходной.
3. Рассуждение завершается по индукции.

**Оптимальность для подзадач** - если оптимальное решение задачи содержит в себе оптимальные решения для всех её подзадач.

---
### Размен монет
Так, например, сумму в 24 копейки монетами в 1, 5 и 7 коп. жадный алгоритм разменивает так: 7 коп. — 3 шт., 1 коп. — 3 шт., в то время как правильное решение — 7 коп. — 2 шт., 5 коп. — 2 шт.

Представим, что кассир должен покупателю сдачу в 41 цент, а у него на поясе есть цилиндры с монетками для сдачи номиналом в 25, 10, 5 и 1 цент. Руководствующийся «жадным» алгоритмом кассир сразу же захочет выдать максимум, на первом же шаге. На этом шаге оптимальным или наилучшим решением будет выдать 25 пенсов. 41-25 = 16. Осталось выдать 16 пенсов. Очевидно, 25 пенсов слишком много, значит, остается 10. 16-10 = 6. Теперь выдаем по тому же принципу 5 пенсов, и затем — 1. Таким образом, покупатель получит всего четыре монеты номиналом 25, 10, 5 и 1 пенс.

---

### Hello World на Java
```java
public class HelloWorld {
   public static void main(String[] args) {
       // Выводим Hello World в консоль.
       System.out.println("Hello, World");
   }
}
```
---
Необходимые основы языка программирования Си для данного курса, были изучены по учебному изданию:
### [The C programming Language, Second Edition, Brian W. Kernighan, Dennis M. Ritchie](http://cpp.com.ru/kr_cbook/)

У меня есть отдельный [конспект](https://github.com/artemiosdev/C_Kernighan_and_Ritchie) по данному учебнику 

---

Примеры кода с лекций:
```C
// Coughs three times.
// Demonstrates better design via a loop.
       
#include <stdio.h>
int main(void)
{
    // cough three times
    for (int i = 0; i < 3; i++)
    {
        printf("cough\n");
    }
}
```

```C
//Coughs three times.
//Demonstrates abstraction and hierarchical decomposition.
#include <stdio.h>
// prototype
void cough(void);
int main(void)
{
    // cough three times
    for (int i = 0; i < 3; i++)
    {
        cough();
    }
}

//Coughs once.
void cough(void)
{
    printf("cough\n");
}
```

```C
//Coughs three times.
// Demonstrates parameterization.
#include <stdio.h>
// prototype
void cough(int n);
int main(void)
{
    // cough three times
    cough(3);
}

//Coughs n times.
void cough(int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("cough\n");
    }
}
```

---
```C
//Prints a user's name.
//Demonstrates a function (not from a library) with a side effect.
#include <cs50.h>
#include <stdio.h>
// prototype
void PrintName(string name);
int main(void)
{
    printf("Your name: ");
    string s = GetString();
    PrintName(s);
}

//Says hello to someone by name.
void PrintName(string name)
{
    printf("hello, %s\n", name);
}
```

---
```C
//Cubes a variable.
//Demonstrates use of parameter and return value.
#include <stdio.h>
// function prototype
int cube(int a);
int main(void)
{
    int x = 2;
    printf("x is now %i\n", x);
    printf("Cubing...\n");
    x = cube(x);
    printf("Cubed!\n");
    printf("x is now %i\n", x);
}

// Cubes argument.
int cube(int n)
{
    return n * n * n;
}
```

---
```C
//Prints a string, one character per line.
//Demonstrates error checking.

#include <cs50.h>
#include <stdio.h>
#include <string.h>
int main (void)
{
 // get line of text
string s = GetString();
 // print string, one character per line
 if(s != NULL)
 {
   for(int i=0; i < strlen(s); i++)
   {
    printf("%c\n", s[i]);
   }
 }
}
```

```C
//Prints a string, one character per line.
//Demonstrates error checking.

#include <cs50.h>
#include <stdio.h>
#include <string.h>
int main (void)
{
 // get line of text
string s = GetString();
 // print string, one character per line
 if(s != NULL)
 {
   for(int i=0; i < strlen(s); i++)
   {
    printf("%c\n", s[i]);
   }
 }
}
```

```C
//Prints a string, one character per line.
//Demonstrates error checking.
#include <cs50.h>
#include <stdio.h>
#include <string.h>
int main (void)
{
 // get line of text
string s = GetString();
 // print string, one character per line
 if(s != NULL)
 {
   for(int i=0, n = strlen(s); i < n; i++)
   {
    printf("%c\n", s[i]);
   }
 }
}
```

---
### Функция 
Некий «чёрный ящик». В этот ящик попадают входные данные ***inputs***, над ними производятся некие манипуляции, а на выходе из этого ящика мы получаем результат ***output***.

-Упорядочивание кода. Код гораздо проще поддерживать, если он разбит на функции, и каждая из них делает чётко определенную небольшую часть работы.

- Упрощение кода. Вам не нужно знать, как работает функция, главное — результат её работы. Это упрощает понимание большой программы.

- Повторное использование. Если вам нужно сделать подобные действия в различных частях программы, можно написать всего одну функцию, и использовать её многократно.

```C
#include <stdio.h>

int cube(int input); //Прототип функции cube

int main(void)
{
     int x = 2;
     printf("x is %i\n", x);
     x = cube(x);
     printf("x is %i\n", x);
}

int cube(int input)
{
     int output = input * input * input;
     return output;
}
```
Result

```bash
x is 2
x is 8
```

***Прототип функции*** (header) называют объявления заголовка функции, без тела. Прототип указывает компилятору, что существует функция с определенным именем, типом результата и списком параметров, тело которой будет описано позже в коде.

***Тип результата (return type)***
На Си нужно всегда указывать тип результата. То есть мы должны явно указать, какого типа будет то значение, которое должна вернуть функция.

***Список параметров (parameter list)***
Перечень входных данных для функции. Функция может не иметь параметров, может иметь один или несколько параметров. Для каждого параметра нужно указать его имя и тип. В примере функция принимает единственный параметр — целое число int input.

В теле (body) описаны действия, которые выполняет функция. Слово *** `return`*** указывает на конец работы функции и указывает значение, которое возвращает функция в качестве результата её работы (значение переменной `output` в примере). Функция может и не возвращать никакого результата.

---
### Указатель в языке Си
Это переменная, содержащая ***адрес объекта***. Указатель не несет информации о содержимом объекта, а содержит сведения о том, где размещен объект.

Память компьютера можно представить в виде последовательности пронумерованных однобайтовых ячеек, с которыми можно работать по отдельности или блоками.

Каждая переменная в памяти имеет свой адрес — номер первой ячейки, где она расположена, а также свое значение. ***Указатель*** — это тоже переменная, которая размещается в памяти. Она тоже имеет адрес, а ее значение является адресом некоторой другой переменной. Переменная, объявленная как указатель, занимает 4 байта в оперативной памяти (в случае 32-битной версии компилятора).

Указатель, как и любая переменная, должен быть объявлен.

***Тип указателя***— это тип переменной, адрес которой он содержит.

Для работы с указателями в Си определены две операции:

***операция * (звездочка)*** — позволяет получить ***значение объекта по его адресу*** — определяет значение переменной, которое содержится по адресу, содержащемуся в указателе;

***операция & (амперсанд)*** — позволяет определить ***адрес переменной***.

```C
char c;   // переменная
char *p; // указатель
p = &c;  // p = адрес c
```
<img alt="image" src="images/указатель.jpg"> </img>

|   | Переменная | Указатель |
|:------------- |:---------------:| -------------:|
| Адрес | &c | p |
| Значение | c | *p |

Программа, меняет местами значения переменных `x` и `y`
```C
#include <stdio.h>

void swap(int* a, int* b); //Прототип функции swap

int main(void)
{
     int x = 1, y = 2;
     swap(&x, &y);
     printf("x is %i\n", x);
     printf("y is %i\n", y);
}

void swap(int* a, int* b)
{
     int tmp = *a;
     *a = *b;
     *b = tmp;
}
```
Result:

```bash
x is 2
y is 1
```

---
### Криптография. Шифр Цезаря и шифр Виженера
***[Шифр Цезаря](https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%A6%D0%B5%D0%B7%D0%B0%D1%80%D1%8F)***

В этом шифре каждая буква текста заменяется на другую, которая находится на фиксированное число букв дальше в алфавите. Это фиксированное число букв называется ***ключом***. Так, ключ 1 переводит букву латиницы C в букву D, а Z — по циклу в A. Если ключ равен 3, то буква C перейдет в F, а Z — в C. 

Примеры: используем шифр Цезаря с ключом 5 на слове cat.
```bash
c -> h
a -> f
t -> y
Caesar (cat, 5) = hfy
```
Обозначим незашифрованный текст буквой `p`, а `pi` — буква в тексте `p`, которая находится на позиции с номером `i`. Назовем секретный ключ буквой `k`, `с` — зашифрованный текст, а `ci` — буква в шифрованном тексте, которая находится на позиции `i`. Тогда вычислить каждую букву шифра можно по формуле: 

`ci = (pi + k) % 26`

Если сопоставить каждому символу алфавита его порядковый номер (нумеруя с 0), то шифрование и дешифрование можно выразить формулами модульной арифметики:

```C
y = (x + k) mod n
x = (y - k) mod n
```
где `x` — символ открытого текста, `y` — символ шифрованного текста, `n` — мощность алфавита, а `k`— ключ

Если ключ `k = 13` а изначальный текст `p` — «Be sure to drink your Ovaltine!», вот какой шифр мы получим:

`Or fher gb qevax lbhe Binygvar!`

Обратите внимание, O (первая буква в шифрованном тексте) смещена на 13 позиций от буквы B (первая буква в оригинальном тексте). То же самое с буквой r (вторая буква в шифровке) смещена на 13 букв от e (вторая буква в оригинале). Третья буква в шифровке, f, смещена на 13 букв от s (третья в оригинале), тут мы ходим по кругу от z до a.

Шифр Цезаря с ключом 13 имеет специальное название `ROT13`. Он симметричный: применив его дважды, мы вернемся к изначальному тексту. 

***[Шифр Виженера](https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%92%D0%B8%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%B0)***

Он несколько безопаснее шифра Цезаря: в качестве ключа в нем используется слово и его сложно взломать вручную с помощью одного только частотного анализа или перебора. Каждая буква ключа генерирует число, и в результате мы получаем несколько ключей для сдвига букв.

<img alt="image" src="images/Шифр Виженера.jpg"> </img>

Пусть `р` – некоторый текст, `k` — ключевое слово, `kj` — `j`-я буква ключа, `pi` — буква под номером `i` в оригинальном тексте, `ci` — буква под номером `i` в шифровке. Тогда:

`ci = (pi + kj) % 26`

Или

Если `n`  — количество букв в алфавите, `mj` — номер буквы открытого текста, `kj` — номер буквы ключа в алфавите, то шифрование Виженера можно записать следующим образом:

`cj = (mj + kj) mod n`

И расшифровывание:

`mj = (cj - kj) mod n`

---

