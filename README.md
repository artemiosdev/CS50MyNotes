

Алгоритм - набор действий для пошагового решения проблемы
Wiki [Algorithm](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC#.D0.9C.D0.B0.D1.88.D0.B8.D0.BD.D0.B0_.D0.A2.D1.8C.D1.8E.D1.80.D0.B8.D0.BD.D0.B3.D0.B0) 

"Hello World" на языке Си

```C
#include <stdio.h>
int main(void) {
  printf("Hello World\n");
  return 0;
}
```

Программы в Cи состоят из функций, а те — из операторов и переменных. **Функция** — это кусок кода, в котором уже есть или подаются какие-то данные, а какие-то данные получаются в результате её исполнения. 

`printf()` из стандартной библиотеки `stdio` выводит любую строку на экран. Строки заключаются в двойные кавычки, а символ `\n` означает перевод курсора на новую строку. 

**Компилятор** - принимает на вход исходный код, и преобразует его в объектный код, т.е в 0 и 1, машинный код понятный компьютеру.

`#include <stdio.h>` - дает доступ к библиотеке функций

Строка `#include` делает очень важную вещь: она подключает библиотеки уже написанного кода к вашей программе. 

Имя подключенной библиотеки идет в угловых скобках `(<>)` и носит расширение `(.h)`. Если бы не было библиотек, то любое, самое элементарное действие, пришлось бы каждый раз описывать снова и снова. Подключенная нами библиотека содержит функции ввода/вывода. Именно она позволяет нам использовать функцию `printf()` для вывода на экран. То есть, если бы мы не написали строку `#include <stdio.h>`, но оставили в теле программы функцию `printf ()`, при попытке запуска мы бы получили ошибку! Потому что без этой библиотеки компилятор не знает, что такое `printf()`. 

Есть библиотеки стандартные, они составляют словарный запас языка. Функция `printf()` не встроена в компьютер, но входит в стандартную библиотеку языка Cи

В технических терминах, библиотека — это двоичный файл, полученный путем объединения в коллекцию объектных файлов, используя компоновщик. **Объектные файлы** — это те файлы с расширением `(*.o)`, которые вы получаете при компиляции приложений

`printf("")` - функция для печати

```bash
$ ./hello
Hello World
```

`clang [name]` - один из компиляторов. Для компиляции можно также использовать уже знакомую вам программу `make`. По сути, она вызывает `clang` с определенными аргументами командной строки. 

`make [name]` - команда компилирует указанный файл `name`

`./a.out` - название первой скомпилированной программы по умолчанию

```bash
$ clang hello.c
$ ./hello
Hello World
$ ./a.out
Hello World
```

```bash
$ make hello
clang   hello.o   -o hello
```

```C
#include<stdio.h>

int main(void)
{
for (int i = 0; i < 10; i++)
printf("hello, world!\n");
}
```

```C
#include <stdio.h>

int main() {
int a, b, c;
    a = 5;
    b = 7;
    c = a + b;
    printf("%d + %d = %d\n", a, b, c);
    return 0;
}
```

Например, библиотека строк [string.h](https://ru.wikipedia.org/wiki/String.h), где описаны операции со строками (определение длины, сложение и прочее) 


255 в двоичной 11111111, так как начало счета с 0 и до 255 = 256 чисел

256 в двоичной 100000000

---

[**Жадный алгоритм**](https://ru.wikipedia.org/wiki/%D0%96%D0%B0%D0%B4%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC) (*Greedy algorithm*) — алгоритм, заключающийся в принятии локально [оптимальных решений](https://ru.wikipedia.org/wiki/Оптимальное_решение) на каждом этапе, допуская, что конечное решение также окажется оптимальным.

Если глобальная оптимальность алгоритма имеет место практически всегда, его обычно предпочитают другим методам оптимизации, таким как [динамическое программирование](https://ru.wikipedia.org/wiki/Динамическое_программирование).

(

**Динамическое программирование** — способ решения сложных задач путём разбиения их на более простые подзадачи. Он применим к задачам с оптимальной подструктурой, выглядящим как набор перекрывающихся подзадач, сложность которых чуть меньше исходной. В этом случае время вычислений, по сравнению с «наивными» методами, можно значительно сократить.

Ключевая идея в динамическом программировании достаточно проста. Как правило, чтобы решить поставленную задачу, требуется решить отдельные части задачи (подзадачи), после чего объединить решения подзадач в одно общее решение. Часто многие из этих подзадач одинаковы. Подход динамического программирования состоит в том, чтобы решить каждую подзадачу только один раз, сократив тем самым количество вычислений. Это особенно полезно в случаях, когда число повторяющихся подзадач экспоненциально велико.

Метод *динамического программирования сверху* — это простое запоминание результатов решения тех подзадач, которые могут повторно встретиться в дальнейшем. *Динамическое программирование снизу* включает в себя переформулирование сложной задачи в виде [рекурсивной](https://ru.wikipedia.org/wiki/Рекурсия) последовательности более простых подзадач.

)

Общего критерия оценки применимости жадного алгоритма для решения конкретной задачи не существует, однако для задач, решаемых жадными алгоритмами, характерны две особенности:

**Принцип жадного выбора** - если последовательность локально оптимальных выборов даёт глобально оптимальное решение. В типичном случае доказательство оптимальности следует такой схеме:

1. Доказывается, что жадный выбор на первом шаге не закрывает пути к оптимальному решению: для всякого решения есть другое, согласованное с жадным выбором и не хуже первого.
2. Показывается, что подзадача, возникающая после жадного выбора на первом шаге, аналогична исходной.
3. Рассуждение завершается по индукции.

**Оптимальность для подзадач** - если оптимальное решение задачи содержит в себе оптимальные решения для всех её подзадач.

---
### Размен монет
Так, например, сумму в 24 копейки монетами в 1, 5 и 7 коп. жадный алгоритм разменивает так: 7 коп. — 3 шт., 1 коп. — 3 шт., в то время как правильное решение — 7 коп. — 2 шт., 5 коп. — 2 шт.

Представим, что кассир должен покупателю сдачу в 41 цент, а у него на поясе есть цилиндры с монетками для сдачи номиналом в 25, 10, 5 и 1 цент. Руководствующийся «жадным» алгоритмом кассир сразу же захочет выдать максимум, на первом же шаге. На этом шаге оптимальным или наилучшим решением будет выдать 25 пенсов. 41-25 = 16. Осталось выдать 16 пенсов. Очевидно, 25 пенсов слишком много, значит, остается 10. 16-10 = 6. Теперь выдаем по тому же принципу 5 пенсов, и затем — 1. Таким образом, покупатель получит всего четыре монеты номиналом 25, 10, 5 и 1 пенс.

---

### HelloWorld на Java
```java
public class HelloWorld {
   public static void main(String[] args) {
       // Выводим Hello World в консоль.
       System.out.println("Hello, World");
   }
}
```
---
---
---

## **The C programming Language**, **Second Edition, Brian W. Kernighan, Dennis M. Ritchie**

## Глава 1. Обзор языка
Программа на Си, каких бы размеров она ни была, состоит из *функций и переменных*. Функции содержат *инструкции*, описывающие вычисления, которые необходимо выполнить, а переменные хранят значения, используемые в процессе этих вычислений.

"Hello World" на языке Си

```C
#include <stdio.h>
int main(void) {
  printf("Hello World\n");
  return 0;
}
```
Приведенная программа - это функция с именем `main`. Обычно вы вольны придумывать любые имена для своих функций, но “main" - особое имя: любая программа начинает свои вычисления с первой инструкции функции `main`.

```C
#include <stdio.h>
```
сообщает компилятору, что он должен включить информацию о стандартной библиотеке ввода-вывода. Эта строка встречается в начале многих исходных файлов Си-программ.

Один из способов передачи данных между функциями состоит в том, что функция при обращении к другой функции передает ей список значений, называемых **аргументами**. Этот список берется в скобки и помещается после имени функции. В нашем примере `main` определена как функция, которая не ждет никаких аргументов, что отмечено пустым списком (void).

```C
printf("Hello World\n");
```

Функция `main` вызывает библиотечную функцию `printf` для печати заданной последовательности символов; `\n` - символ новой строки. Символ новой строки никогда не вставляется автоматически.

Функция `printf` - это библиотечная функция, которая в данном случае напечатает последовательность символов, заключенную в двойные кавычки.

```C
#include <stdio.h>
/* печать таблицы температур по Фаренгейту
и Цельсию для fahr = 0, 20, ..., 300 */
main()
{
    int fahr, celsius;
    int lower, upper, step;

    lower = 0; /* нижняя граница таблицы температур */
    upper = 300; /* верхняя граница */
    step = 20;  /* шаг */

    fahr = lower;
    while (fahr <= upper) {
        celsius = 5 * (fahr-32) / 9;
        printf(“%d\t%d\n”, fahr, celsius);
        fahr = fahr + step;
    }
}
```
```bash
0	-17
20	-6
40	4
60	15
80	26
100	37
120	48
140	60
160	71
180	82
200	93
220	104
240	115
260	126
280	137
300	148
```

В Си любая переменная должна быть объявлена раньше, чем она будет использована; обычно все переменные объявляются в начале функции перед первой исполняемой инструкцией. В объявлении описываются свойства переменных. Оно состоит из названия типа и списка переменных, например:

```C
int fahr, celsius;
int lower, upper, step;
```
Тип `int` означает, что значения перечисленных переменных есть целые, в отличие от него тип `float` указывает на значения с плавающей точкой, т. е. на числа, которые могут иметь дробную часть.

Числа типа `int` бывают как 16-разрядные (лежат в диапазоне от -32768 до 32767), так и 32-разрядные. Числа типа `float` обычно представляются 32-разрядными словами, имеющими по крайней мере 6 десятичных значащих цифр (лежат приблизительно в диапазоне от 10-38 до 10+38.

Помимо `int` и `float` в Си имеется еще несколько базовых типов для данных, это:

`char` - символ-единичный байт;
`short` - короткое целое;
`long` - длинное целое;
`double` - с плавающей точкой с двойной точностью.

| Тип |	Определение |	Диапазон значений |	Размер в байтах |
| :---------: | :---------- | :---------- | :---------: |
|int |	Целые числа |	-2 147 483 648 до 2 147 483 647	|  4|
|short int |	Короткие целые числа | -32 768 до 32 767	|  2|
|float |  Дробные числа (числа с плавающей запятой)	| -2 147 483 648.0 до 2 147 483 647.0	| 4 (32 bit) |
|double |	Дробные числа двойной точности	| -9 223 372 036 854 775 808 .0 до 9 223 372 036 854 775 807.0 | 8|
|long float |	Длинные дробные числа (зависит от системы) |	-9 223 372 036 854 775 808 .0 до 9 223 372 036 854 775 807.0 | 8|
|char | Символы | ‘Q’; ‘f’; ‘:’; ‘@’ | 1|
|string | Строковые данные | строки, которые можно закодировать в 32 разрядах или меньше | 4|
|bool | Булевы выражения | true; false | 1|

Программа выполняет вычисления по формуле `°С = (5/9)(°F-32`) и печатает таблицу соответствия температур по Фаренгейту температурам по Цельсию

```
celsius = 5 * (fahr-32) / 9;
```
Причина, по которой мы сначала умножаем на 5 и затем делим на 9, а не сразу умножаем на 5/9, связана с тем, что в Си, как и во многих других языках, деление целых сопровождается **отбрасыванием**, т. е. потерей дробной части. Так как 5 и 9 - целые, отбрасывание в 5/9 дало бы нуль, и на месте температур по Цельсию были бы напечатаны нули.

**Функция printf** - это универсальная функция форматного ввода-вывода. Ее первый аргумент - строка символов, в которой каждый символ `%` соответствует одному из последующих аргументов (второму, третьему, ...), а информация, расположенная за символом `%`, указывает на вид, в котором выводится каждый из этих аргументов. Например, `%d` специфицирует выдачу аргумента в виде целого десятичного числа, и инструкция

```C
printf(“%d\t%d\n”, fahr, celsius);
```
печатает целое `fahr`, выполняет табуляцию `(\t)` и печатает целое `celsius`.

В функции `printf` каждому спецификатору первого аргумента (конструкции, начинающейся с `%`) соответствует второй аргумент, третий аргумент и т. д. Спецификаторы и соответствующие им аргументы должны быть согласованы по количеству и типам: в противном случае напечатано будет не то, что нужно.


Например, 0°F на самом деле (с точностью до десятой) равно -17.8°С, а не -17. Чтобы получить более точные значения температур, нам надо пользоваться не целочисленной арифметикой, а арифметикой с плавающей точкой.

```C
#include <stdio.h>
/* печать таблицы температур по Фаренгейту и Цельсию для fahr = 0, 20, . .., 300; вариант с плавающей точкой   */
main()
{
    float fahr, celsius;
    int lower, upper, step;

    lower = 0;   /* нижняя граница таблицы температур */ 
    upper = 300; /* верхняя граница */ 
    step = 20;   /* шаг */

    fahr = lower;
    while (fahr <= upper) { 
        celsius = (5.0/9.0) * (fahr-32.0);
        printf(“%3.0f %6.1f\n”, fahr, celsius);
        fahr = fahr + step;
    }
}
```

`printf(“%3.0f %6.1f\n”, fahr, celsius);`
Спецификация *%3.0f* в *printf* определяет печать числа с плавающей точкой (в данном случае числа *fahr*) в поле шириной не более трех позиций без десятичной точки и дробной части. Спецификация *%6.1f* описывает печать другого числа (*celsius*) в поле из шести позиций с одной цифрой после десятичной точки

```bash
  0  -17.8
 20   -6.7
 40    4.4
 60   15.6
 80   26.7
100   37.8
120   48.9
140   60.0
160   71.1
180   82.2
200   93.3
220  104.4
240  115.6
260  126.7
280  137.8
300  148.9
```

`%d`	- печать десятичного целого.
`%6d`	- печать десятичного целого в поле из шести позиций.
`%f`	- печать числа с плавающей точкой.
`%6f` - печать числа с плавающей точкой в поле из шести позиций.
`%.2f`	- печать числа с плавающей точкой с двумя цифрами после десятичной точки.
`%6.2f`	- печать числа с плавающей точкой и двумя цифрами после десятичной точки в поле из шести позиций.
Кроме того, printf допускает следующие спецификаторы: `%o` для восьмеричного числа; `%x` для шестнадцатеричного числа; `%c` для символа; `%s` для строки символов и `%%` для самого %.

Упражнение 1.4. Напишите программу, которая будет печатать таблицу соответствия температур по Цельсию температурам по Фаренгейту.

```C
#include <stdio.h>
main()
{
    float fahr, celsius;
    int lower, upper, step;

    lower = 0;   /* нижняя граница таблицы температур */ 
    upper = 300; /* верхняя граница */ 
    step = 20;   /* шаг */

    celsius = lower;
          printf("Таблица\n");
    while (celsius <= upper) { 
        fahr = (9.0 * celsius) / 5.0 + 32.0;
        printf("%3.0f %6.0f\n", celsius, fahr);
        celsius = celsius + step;
    }
}
```
```bash
Таблица 
  0     32
 20     68
 40    104
 60    140
 80    176
100    212
120    248
140    284
160    320
180    356
200    392
220    428
240    464
260    500
280    536
300    572
```

---
### Инструкция for
Видоизменим нашу программу преобразования температур:

```C
#include <stdio.h>
/* печать таблицы температур по Фаренгейту и Цельсию */
main()
{
    int fahr;
    for (fahr = 0; fahr <= 300; fahr = fahr + 20)
        printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));
}
```
Выражение, вычисляющее температуру по Цельсию, теперь задано третьим аргументом функции `printf`, а не в отдельной инструкции присваивания.

Последнее изменение является примером применения общего правила: **в любом контексте, где возможно использовать значение переменной какого-то типа, можно использовать более сложное выражение того же типа**. Так, на месте третьего аргумента функции `printf` согласно спецификатору `%6.1f` должно быть значение с плавающей точкой, следовательно, здесь может быть любое выражение этого типа.

---
### Именованные константы
Строка `#define` определяет символьное имя, или именованную константу, для заданной строки символов:

```c
#define имя подставляемый-текст
```
С этого момента при любом появлении имени оно будет заменяться на соответствующий ему подставляемый-текст.

```C
#include <stdio.h>

#define LOWER 0   /* нижняя граница таблицы */
#define UPPER 300 /* верхняя граница */
#define STEP 20   /* размер шага */

/* печать таблицы температур по Фаренгейту и Цельсию */
main()
{
    int fahr;
    for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
        printf(“%3d %6.1f\n”, fahr, (5.0/9.0)*(fahr-32));
}
```

LOWER, UPPER и STEP - именованные константы, а не переменные, поэтому для них нет объявлений. По общепринятому соглашению имена именованных констант набираются заглавными буквами, чтобы они отличались от обычных переменных, набираемых строчными. Заметим, что в конце `#define-строки` точка с запятой не ставится.

---
### `getchar` и `putchar
Стандартная библиотека включает несколько функций для чтения и записи одного символа. Простейшие из них - `getchar` и `putchar`. За одно обращение к `getchar` считывается следующий символ ввода из текстового потока, и этот символ выдается в качестве результата. Так, после выполнения

```C
c = getchar();
```
переменная `c` содержит очередной символ ввода. Обычно символы поступают с клавиатуры. 

Обращение к `putchar` приводит к печати одного символа. 

```C
putchar(c);
```
напечатает содержимое целой переменной `c` в виде символа (обычно на экране). Вызовы `putchar` и `printf` могут произвольным образом перемежаться. Вывод будет формироваться в том же порядке, что и обращения к этим функциям.

---
### Копирование файла
Программа, копирующая по одному символу с входного потока в выходной поток:

```C
    чтение символа
    while (символ не является признаком конца файла)
    вывод только что прочитанного символа
    чтение символа
```

```C
#include <stdio.h>
/* копирование ввода на вывод, 1-я версия */
main()
{
    int c;
    c = getchar();
    while (c != EOF) {
        putchar(c);
        c = getchar();
    }
}
```
Оператор отношения `!=` означает “не равно”

Каждый символ, вводимый с клавиатуры или появляющийся на экране, как и любой другой символ внутри машины, кодируется комбинацией битов. Тип `char` специально предназначен для хранения символьных данных, однако для этого также годится и любой целый тип. Мы пользуемся типом `int` и делаем это по одной важной причине, которая требует разъяснений.

Существует проблема: как отличить конец ввода от обычных читаемых данных. Решение заключается в том, чтобы функция getchar по исчерпании входного потока выдавала в качестве результата такое значение, которое нельзя было бы спутать ни `с` одним реальным символом. Это значение есть **EOF (аббревиатура от end of file - конец файла)**. Мы должны объявить переменную `c` такого типа, чтобы его “хватило” для представления всех возможных результатов, выдаваемых функцией `getchar`. Нам не подходит тип `char`, так как c должна быть достаточно “емкой”, чтобы помимо любого значения типа `char` быть в состоянии хранить и EOF. Вот почему мы используем `int`, а не `char`.

EOF - целая константа, определенная в `<stdio.h>`. Какое значение имеет эта константа - неважно, лишь бы оно отличалось от любого из возможных значений типа `char`. Использование именованной константы с унифицированным именем гарантирует, что программа не будет зависеть от конкретного числового значения, которое, возможно, в других Си-системах будет иным.

Цикл `while`, пересылая в `c` полученное от `getchar` значение, сразу же проверяет: не является ли оно “концом файла”. Если это не так, выполняется тело цикла `while` и печатается символ. По окончании ввода завершается работа цикла `while`, а тем самым и `main`.

---
### Подсчет символов
```C
#include <stdio.h>
/* подсчет вводимых символов; 1-я версия */ 
main()
{
    long nc;
    nc = 0;
    while (getchar() != EOF) {
        ++nc;
    printf(“%ld\n”, nc);
    }
}
```
Инструкция `++nc;` представляет новый оператор ` ++ `, который означает увеличить на единицу. Вместо этого можно было бы написать `nc=nc+1`, но ++nc короче, а часто и эффективнее. Существует аналогичный оператор ` -- `, означающий уменьшить на единицу. Операторы ` ++ ` и ` -- ` могут быть как префиксными `(++nc)`, так и постфиксными `(nc++)`. 

Программа подсчета символов накапливает сумму в переменной типа `long`. Целые типа long имеют не менее 32 битов. Хотя на некоторых машинах типы `int` и `long` имеют одинаковый размер, существуют, однако, машины, в которых `int` занимает 16 бит с максимально возможным значением 32767, а это - сравнительно маленькое число, и счетчик типа `int` может переполниться. Спецификация `%ld` в `printf` указывает, что соответствующий аргумент имеет тип `long`.

Возможно охватить еще больший диапазон значений, если использовать тип `double` (т. е. `float` с двойной точностью). Применим также инструкцию `for` вместо `while`, чтобы продемонстрировать другой способ написания цикла.

```C
#include <stdio.h>
/* подсчет вводимых символов; 2-й версия */
main()
{
    double nc;
    for (nc = 0; getchar() != EOF; ++nc) {
        ;
    printf(“%.0f\n”, nc);
    }
}
```
В `printf` спецификатор `%f` применяется как для `float`, так и для `double`; спецификатор `%.0f` означает печать без десятичной точки и дробной части (последняя в нашем случае отсутствует).

Тело указанного for-цикла пусто, поскольку кроме проверок и приращений счетчика делать ничего не нужно. Но правила грамматики Си требуют, чтобы for-цикл имел тело. Выполнение этого требования обеспечивает изолированная точка с запятой, называемая пустой инструкцией. 

---
### Подсчет строк
```C
#include <stdio.h>
/* подсчет строк входного потока */
main()
{
    int c, nl;
    nl = 0;
    while ((c = getchar()) != EOF){
        if (c == '\n')
            ++nl;
    printf(“%d\n”, nl);
    }
}
```
Тело цикла теперь образует инструкция `if`, под контролем которой находится увеличение счетчика `nl` на единицу. Инструкция `if` проверяет условие в скобках и, если оно истинно, выполняет следующую за ним инструкцию.

---
### Подсчет слов
Программа подсчитывает строки, слова и символы, причем под словом здесь имеется в виду любая строка символов, не содержащая в себе пробелов, табуляций и символов новой строки. Эта программа является упрощенной версией программы `wc` системы UNIX.

```bash
flyboroda@MacBook-Air-Artem ~ % cd Documents/MyGit/CS50MyNotes 
flyboroda@MacBook-Air-Artem CS50MyNotes % wc README.md 
     526    3291   35240 README.md
```
Программa выведет три числа, обозначающих количество строк, слов и байт введённой информации.

```C
#include <stdio.h>

#define IN 1	/* внутри слова */
#define OUT 0	/* вне слова */
/* подсчет строк, слов и символов */
main()
{
    int с, nl, nw, nc, state;
    state = OUT;
    nl = nw = nc = 0;
    while ((с = getchar()) != EOF) {
        ++nc;
        if (c == '\n')
            ++nl;
        if (c == ' ' || c == '\n' || c == '\t')
            state = OUT;
        else if (state == OUT) {
            state = IN;
            ++nw;
        }
    }
    printf(“%d %d %d\n”, nl, nw, nc);
}
```

Каждый раз, встречая первый символ слова, программа изменяет значение счетчика слов на 1. Переменная `state` фиксирует текущее состояние - находимся мы внутри или вне слова. Вначале ей присваивается значение `OUT`, что соответствует состоянию “вне слова”. Мы предпочитаем пользоваться именованными константами `IN` и `OUT`, а не собственно значениями 1 и 0, чтобы сделать программу более понятной.

Упражнение 1.12. Напишите программу, которая печатает содержимое своего ввода, помещая по одному слову на каждой строке.
```C
#include <stdio.h>
#define IN 1 //внутри слова
#define OUT 0 //вне слова

int main()
{
 int c, state;
 state = OUT;
 while ((c = getchar()) != EOF) {
  if ( c == ' ' || c == '\t' || c == '\n') {
   state = OUT;
  }
  else if (state == OUT) {
   putchar('\n');
   state = IN;
  }
  putchar(c);
 }
 return 0;
}
```
```
My name is Artem
My 
name 
is 
Artem
```

---
### Массивы
А теперь напишем программу, подсчитывающую по отдельности каждую цифру, символы-разделители (пробелы, табуляции и новые-строки) и все другие символы. Имеется двенадцать категорий вводимых символов. Удобно все десять счетчиков цифр хранить в массиве, а не в виде десяти отдельных переменных. Вот один из вариантов этой программы:

```C
#include <stdio.h>

/* подсчет цифр, символов-разделителей и прочих символов */
int main()
{
    int c, i, nwhite, nother;
    int ndigit[10];

    nwhite = nother = 0;
    for (i = 0; i < 10; ++i) {
        ndigit[i]= 0;
    }

    while ((c = getchar()) != EOF) {
        if (c >='0' && c <= '9') {
            ++ndigit[c - '0'];
        }
        else if (c == ' ' || c == '\n' || c == '\t') {
            ++nwhite;
        }
        else {
            ++nother;
        }
    }

    printf("цифры =");
    for (i = 0; i < 10; ++i) {
        printf("%d", ndigit[i]);
    }
    printf(", символы-разделители =%d, прочие =%d\n", nwhite, nother);
}
```
```bash
The C programming Language
цифры =0000000000, символы-разделители =4, прочие =23
```

Объявление `int ndigit[10];` - объявляет `ndigit` массивом из 10 значений типа `int`. В Си элементы массива всегда нумеруются начиная с нуля, так что элементами этого массива будут `ndigit[0], ndigit[1], ..., ndigit[9]`, что учитывается в for-циклах (при инициализации и печати массива).

По определению, значения типа `char` являются просто малыми целыми, так что переменные и константы типа `char` в арифметических выражениях идентичны значениям типа `int`. Это и естественно, и удобно; например, `c-'0'` есть целое выражение с возможными значениями от 0 до 9, которые соответствуют символам от '0' до '9', хранящимся в переменной `c`. Таким образом, значение данного выражения является правильным индексом для массива `ndigit`.


Упражнение 1.13. Напишите программу, печатающую гистограммы длин вводимых слов. Гистограмму легко рисовать горизонтальными полосами. 

```C
#include <stdio.h>
#define IN 1
#define OUT 0
/*печатает гистограммы длин вводимых слов*/
 
int main()
{
int c, state;
state = OUT;
 
while ((c = getchar()) != EOF)
{
    if (c != ' ' && c != '\n' && c != '\t')
    {
        state = IN;
        putchar('-');
    }
    else if (state == IN)
    {
        state = OUT;
        putchar('\n');
    }
}
    return 0;
}
```
Inputs: `The C programming Language Brian W. Kernighan, Dennis M. Ritchie`
Result:
```bash
---
-
-----------
--------
-----
--
----------
------
--
-------
```

---
or another decision 
```C
#include <stdio.h>
/*подсчет символов в словах и печатание горизонтальной гистограммы с количеством символов*/
#define IN 1 /*внутри слова*/
#define OUT 2 /*вне слова*/
 
int main()
{
int c, nc, state;
nc = 0; state = OUT;
 
while ((c = getchar()) != EOF) {
    if (c != ' ' && c != '\n' && c != '\t')
        {state = IN;++nc; /*когда внутри слова-вклячается счетчик символов*/
        putchar('-'); } /*печатаем горизонтальную гистограмму этого слова*/
    else if (state == IN){
        state = OUT; printf("%d",nc); /*когда слово закончилось-печатаем количество символов в этом слове*/
        putchar('\n'); nc = 0;} /*переходим на новую строку и обнуляем счетчик символов, иначе он будет печатать общее количество символов всех слов*/
}
    return 0;
}
```
Inputs: `The C programming Language Brian W. Kernighan, Dennis M. Ritchie`
Result:
```bash
---3
-1
-----------11
--------8
-----5
--2
----------10
------6
--2
-------7

```

----
or another decision 
```C
#include <stdio.h>
main()
{
        int c;
        while ((c=getchar()) != EOF) {
                if (c == ' ' || c == '\n' || c == '\t')
                        printf("\n");
                else
                        printf("_");
        }
}
```

Inputs: `The C programming Language Brian W. Kernighan, Dennis M. Ritchie`
Result:
```bash
___
_
___________
________
_____
__
__________
______
__
_______
```

---
Рисование вертикальными полосами - более трудная задача.

```C
#include <stdio.h>
/*программа печатающая вертикальную гистограмму вводимых символов в словах*/
#define IN 1 /*внутри слова*/
#define OUT 0/*вне слова*/
#define MAXWORDS 80 /*максимальное количество слов в нашей гистограмме 80*/
 
int main()
{
int i, j, c, state; /*i-индекс массива слов, j-количество символов в слове, с - вводимый символ, state - состояние переменной с ( IN - внутри слова, OUT - вне слова) */
int lenword [MAXWORDS], nextword, maxlen; /*счетчик массива слов,следующее слово,самое длинное слово*/
nextword = maxlen = 0;
for (i = 0; i < MAXWORDS; ++i)    /*инициализируем цикл*/
    lenword [i] = 0;
state = OUT;
 
while ((c = getchar())!= EOF && nextword < MAXWORDS) {
    if ( c == ' ' || c == '\n' || c == '\t'){    /*1.если сначала вводится символ-разделитель,то */
        if (state == IN){                        /*программа ничего не делает,т.к. не выполняется*/
            if (lenword [nextword] > maxlen)     /*условие state == IN;( у нас state == OUT)*/
                    maxlen = lenword [nextword]; /*2.если вводится любой другой символ,программа */
        ++nextword; state = OUT; }               /*переходит к else, state становится IN и включа*/
    }                                            /*ется счетчик lenword [0],т.е. счетчик первого */
    else {                                   /*слова массива*/
        if (state == OUT)                        /*3.при появлении на вводе символа-разделителя */
            state = IN;                          /*(условие state == IN на этот раз выполнено) */
            ++lenword [nextword];                /*проверяется условие lenword [0] > maxlen, оно */
            }    /*истинно и тогда maxlen = lenword [0]. 4.переменная nextword увеличивается на 1 */
          }      /* т.е. счетчик символов приобретает индекс 1-lenword[1],state присваивается OUT */
for (j = maxlen; j > 0; --j){    /* Печатание гистограммы. 1.Переменной j присваисается значение */
    for(i = 0; i < nextword; ++i){ /*самого длинного слова из введенных,т.е. maxlen,это будет */
        if (lenword[i] >= j)       /*высота нашей гистограммы. 2. Цикл внутри цикла for печатает */
            putchar('#');          /*строку начиная со счетчика первого слова lenword[0], если */
        else                       /*это не самое длинное слово то печатается пробел,цикл перехо-*/
                putchar(' ');      /*дит к следующему слову (++i) и каретка смещается на одно поле*/
                }                  /*вправо.Когда цикл доходит до самого длинного слова,то печатает*/
     putchar('\n') ;               /*#. 3.Когда "внутренний" цикл доходит до последнего слова*/
}                                  /*условие i < nextword перестает выполняться и цикл завершает свою работу и программа переходит к функции putchar('\n'),*/
        return 0;                  /*т.е. каретка принтера переходит на новую строку. 4.выполняется */
}                                  /* --j и запускается следующий цикл "наружного" цикла for. */
                                   /*5. когда j дойдет до нуля,условие j>0 перестанет выполняться и цикл прекратит работу.   Программа завершена.  */
                                   
```

Inputs: `The C programming Language Brian W. Kernighan, Dennis M. Ritchie`
Result:
```bash
  #       
  #   #   
  #   #   
  ##  #   
  ##  #  #
  ##  ## #
  ### ## #
  ### ## #
# ### ## #
# ########
##########
```

Упражнение 1.14. Напишите программу, печатающую гистограммы частот встречаемости вводимых символов.

```C
#include <stdio.h>
/* Задание 1,14 Гистограмма частот встречаемости введенных символов подсчитываются символы с ASCII-кодами от 0 до 255 */
int main(){
    int c;                          // переменная для ввода символов
    int i, j;                        // счетчики циклов
    int size = 255;           // размер массива
    int symbols[size];      // сам массив
 
    printf("Enter text: \n"); 
 
    /* заполняем массив нулями */
    for(i = 0; i < size; ++i)
        symbols[i] = 0;
 
    /* пока не достигнут конец файла, считываем символы и записываем их в массив*/
    while((c = getchar()) != EOF)
    {
        ++symbols[c];
 
        /* Если объем символов превысил размер массива, установить размер равным 255 */
        if(symbols[c] > size)
        {
            size = 255;
        }
    }
 
    /* выводим массив на печать, заменяя повторяющиеся символы на знак "#" */
    for(i = 0; i < size; i++)
    {
        if(symbols[i] > 0)
        {
                printf("Symbol: '%c' - ", i);
                for(j = 0; j < symbols[i]; ++j) { printf("#"); }
                printf("\n"); 
        }
    }
 
        return 0;
}
```

Inputs: `The C programming Language Brian W. Kernighan, Dennis M. Ritchie`
Result:
```bash
Enter text: 
Symbol: '
' - #
Symbol: ' ' - #########
Symbol: ',' - #
Symbol: '.' - ##
Symbol: 'B' - #
Symbol: 'C' - #
Symbol: 'D' - #
Symbol: 'K' - #
Symbol: 'L' - #
Symbol: 'M' - #
Symbol: 'R' - #
Symbol: 'T' - #
Symbol: 'W' - #
Symbol: 'a' - #####
Symbol: 'c' - #
Symbol: 'e' - #####
Symbol: 'g' - #####
Symbol: 'h' - ###
Symbol: 'i' - ######
Symbol: 'm' - ##
Symbol: 'n' - #######
Symbol: 'o' - #
Symbol: 'p' - #
Symbol: 'r' - ####
Symbol: 's' - #
Symbol: 't' - #
Symbol: 'u' - #
```

---
### Функции
Функция обеспечивает удобный способ отдельно оформить некоторое вычисление и пользоваться им далее, не заботясь о том, как оно реализовано. После того, как функции написаны, можно забыть, как они сделаны, достаточно знать лишь, что они умеют делать.

Функция `power(m, n)`, которая возводит целое `m` в целую положительную степень `n`. Так, `power(2, 5)` имеет значение 32.
Мы имеем функцию `power` и главную функцию `main`, пользующуюся ее услугами

```C
#include <stdio.h>

int power(int m, int n);
/* тест функции power */
main()
{
    int i;
    for (i = 0; i < 10; ++i)
        printf("%d %d %d\n", i, power(2,i), power(-3,i));
    return 0;
}

/* возводит base в n-ю степень, n >= 0 */
int power(int base, int n)
{
    int i, p;

    p = 1;
    for (i = 1; i <= n; ++i)
        p = p * base;
    return p;
}
```

Определение любой функции имеет следующий вид:

```bash
тип-результата имя-функции (список параметров, если он есть)
{
    объявления
    инструкции
}
```

В первой строке определения `power`:

```C
int power(int base, int n);
```
указываются типы параметров, имя функции и тип результата. Имена параметров локальны внутри power, это значит, что они скрыты для любой другой функции, так что остальные подпрограммы могут свободно пользоваться теми же именами для своих целей. Последнее утверждение справедливо также для переменных `i` и `p`: `i` в `power` и `i` в `main` не имеют между собой ничего общего.

Далее ***параметром*** мы будем называть переменную из списка параметров, заключенного в круглые скобки и заданного в определении функции, а ***аргументом*** - значение, используемое при обращении к функции. Иногда в том же смысле мы будем употреблять термины формальный аргумент и фактический аргумент.

Значение, вычисляемое функцией `power`, возвращается в `main` с помощью инструкции `return`. За словом `return` может следовать любое выражение:

```C
return выражение;
```
Функция не обязательно возвращает какое-нибудь значение. Инструкция `return` без выражения только передает управление в ту программу, которая ее вызвала, не передавая ей никакого результирующего значения. То же самое происходит, если в процессе вычислений мы выходим на конец функции, обозначенный в тексте последней закрывающей фигурной скобкой. Возможна ситуация, когда вызывающая функция игнорирует возвращаемый ей результат.

Вы, вероятно, обратили внимание на инструкцию `return` в конце `main`. Поскольку `main` есть функция, как и любая другая она может вернуть результирующее значение тому, кто ее вызвал, - фактически в ту среду, из которой была запущена программа. Обычно возвращается нулевое значение, что говорит о нормальном завершении выполнения. Ненулевое значение сигнализирует о необычном или ошибочном завершении. До сих пор ради простоты мы опускали `return` в `main`, но с этого момента будем задавать `return` как напоминание о том, что программы должны сообщать о состоянии своего завершения в операционную систему.

Объявление

```C
int power(int m, int n);
```
стоящее непосредственно перед `main`, сообщает, что функция `power` ожидает двух аргументов типа `int` и возвращает результат типа `int`. Это объявление, называемое прототипом функции, должно быть согласовано с определением и всеми вызовами `power`. Если определение функции или вызов не соответствует своему прототипу, это ошибка.

Имена параметров не требуют согласования. Фактически в прототипе они могут быть произвольными или вообще отсутствовать.

---
### Аргументы. Вызов по значению
В Си все аргументы функции передаются ***“по значению”***. Это следует понимать так, что вызываемой функции посылаются значения ее аргументов во временных переменных, а не сами аргументы.

Главное отличие заключается в том, что в Си вызываемая функция **не может непосредственно изменить переменную вызывающей функции**: она может изменить только ее частную, временную копию. Однако вызов по значению следует отнести к достоинствам языка, а не к его недостаткам.  

Пример, приведем еще одну версию функции `power`, в которой как раз использовано это свойство.

```C
/* power: возводит base в n-ю степень; n >= 0, версия 2 */
int power(int base, int n)
{
    int p;
    for (p = 1; n > 0; --n)
        p = p * base;
    return p;
}
```

Параметр ` n ` выступает здесь в роли временной переменной, в которой циклом `for` в убывающем порядке ведется счет числа шагов до тех пор, пока ее значение не станет нулем. При этом отпадает надобность в дополнительной переменной ` i ` для счетчика цикла. Что бы мы ни делали с ` n ` внутри `power`, это не окажет никакого влияния на сам аргумент, копия которого была передана функции `power` при ее вызове.

Механизм передачи массива в качестве аргумента несколько иной. Когда аргументом является имя массива, то функции передается значение, которое является адресом начала этого массива; никакие элементы массива не копируются. С помощью индексирования относительно полученного значения функция имеет доступ к любому элементу массива.

---
### Символьные массивы
Напишем программу, которая читает набор текстовых строк и печатает самую длинную из них. Ее схема :

```C
while (есть ли еще строка?)
    if (данная строка длиннее самой длинной из предыдущих)
        запомнить ее
        запомнить ее длину
напечатать самую длинную строку
```
Из схемы видно, что программа естественным образом распадается на части. Одна из них получает новую строку, другая проверяет ее, третья запоминает, а остальные управляют процессом вычислений.

Cначала напишем отдельную функцию `getline` для получения очередной строки. Мы попытаемся сделать эту функцию полезной и для других применений. Как минимум `getline` должна сигнализировать о возможном конце файла, а еще лучше, если она будет выдавать длину строки — или нуль в случае исчерпания файла. Нуль годится для признака конца файла, поскольку не бывает строк нулевой длины, даже строка, содержащая только один символ новой строки, имеет длину 1.

Когда мы обнаружили строку более длинную, чем самая длинная из всех предыдущих, то нам надо будет где-то ее запомнить. Здесь напрашивается вторая функция, `copy`, которая умеет копировать новую строку в надежное место.

Наконец, нам необходима главная программа, которая бы управляла функциями `getline` и `copy`. Вот как выглядит наша программа в целом:

```C
#include <stdio.h>
#define MAXLINE 1000 /* максимальный размер вводимой строки */

int getline(char line[], int MAXLINE);
void copy(char to[], char from[]);

/* печать самой длинной строки */
main()
{
    int len; /* длина текущей строки */
    int max; /* длина максимальной из просмотренных строк */
    char line[MAXLINE]; /* текущая строка */
    char longest[MAXLINE]; /* самая длинная строка */
    max = 0;
    while (len = getline(line, MAXLINE)) > 0)
        if (len > max) {
            max = len;
            copy(longest, line);
        }
    if (max > 0) /* была ли хоть одна строка? */
        printf(“%s”, longest);
    return 0;
}


/* getline: читает строку в s, возвращает длину */
int getline(char s[], int lim)
{
    int c, i;

    for (i = 0; i < lim-1 && (c = getchar()) != EOF && с != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

/* copy: копирует из 'from' в 'to'; to достаточно большой */
void copy(char to[], char from[])
{
    int i;

    i = 0;
    while ((to[i] = from[i]) != '\0')
        ++i;
}
```

Функции `main` и `getline` взаимодействуют между собой через пару аргументов и возвращаемое значение. В `getline` аргументы определяются строкой

`int getline(char s[], int lim);`
Как мы видим, ее первый аргумент `s` есть массив, а второй, `lim`, имеет тип `int`. Задание размера массива в определении имеет целью резервирование памяти. В самой `getline` задавать длину массива `s` нет необходимости, так как его размер указан в `main`. Чтобы вернуть значение вызывающей программе, `getline` использует `return` точно так же, как это делает функция `power`. В приведенной строке также сообщается, что getline возвращает значение типа `int`, но так как при отсутствии указания о типе подразумевается `int`, то перед `getline` слово `int` можно опустить.

Одни функции возвращают результирующее значение, другие (такие как `copy`) нужны только для того, чтобы произвести какие-то действия, не выдавая никакого значения. На месте типа результата в `copy` стоит `void`. Это явное указание на то, что никакого значения данная функция не возвращает.

Функция `getline` в конец создаваемого ею массива помещает символ `'\0'` (null-символ, кодируемый нулевым байтом), чтобы пометить конец строки символов. То же соглашение относительно окончания нулем соблюдается и в случае строковой константы вроде

`“hello\n”`
В данном случае для него формируется массив из символов этой строки с `'\0'` в конце.

`h е l l o \n \0`

Спецификация `%s` в формате `printf` предполагает, что соответствующий ей аргумент - строка символов, оформленная указанным выше образом. Функция `copy` в своей работе также опирается на тот факт, что читаемый ею аргумент заканчивается символом `'\0'`, который она копирует наряду с остальными символами. (Всё сказанное предполагает, что `'\0'` не встречается внутри обычного текста.)

Попутно стоит заметить, что при работе даже с такой маленькой программой мы сталкиваемся с некоторыми конструктивными трудностями. Например, что должна делать `main`, если встретится строка, превышающая допустимый размер? Функция `getline` работает надежно: если массив полон, она прекращает пересылку, даже если символа новой строки не обнаружила. Получив от `getline` длину строки и увидев, что она совпадает с `MAXLINE`, главная программа `main` могла бы “отловить” этот особый случай и справиться с ним.

Пользователи `getline` не могут заранее узнать, сколь длинными будут вводимые строки, поэтому `getline` делает проверки на переполнение. А вот пользователям функции `copy` размеры копируемых строк известны (или они могут их узнать), поэтому дополнительный контроль здесь не нужен.

---
### Внешние переменные и область видимости
Переменные `line`, `longest` и прочие принадлежат только функции `main`, и локальны в ней. Поскольку они объявлены внутри `main`, никакие другие функции прямо к ним обращаться не могут. То же верно и применительно к переменным других функций. Например, `i` в `getline` не имеет никакого отношения к `i` в `copy`. Каждая локальная переменная функции возникает только в момент обращения к этой функции и исчезает после выхода из нее.

Так как автоматические переменные образуются и исчезают одновременно с входом в функцию и выходом из нее, они не сохраняют своих значений от вызова к вызову и должны устанавливаться заново при каждом новом обращении к функции. Если этого не делать, они будут содержать “мусор”.

В качестве альтернативы можно определить внешние переменные, к которым разрешается обращаться по их именам из любой функции. Так как внешние переменные доступны повсеместно, их можно использовать вместо аргументов для связи между функциями по данным. Кроме того, поскольку внешние переменные существуют постоянно, а не возникают и исчезают на период выполнения функции, свои значения они сохраняют и после возврата из функций, их установивших.

Внешняя переменная должна быть определена, причем только один раз, вне текста любой функции; в этом случае ей будет выделена память. Она должна быть объявлена во всех функциях, которые хотят ею пользоваться. Объявление содержит сведения о типе переменной. Объявление может быть явным, в виде инструкции `extern`, или неявным, когда нужная информация получается из контекста. Чтобы конкретизировать сказанное, перепишем программу печати самой длинной строки с использованием `line`, `longest` и `max` в качестве внешних переменных. Это потребует изменений в вызовах, объявлениях и телах всех трех функций.

```C
#include <stdio.h>

#define MAXLINE 1000 /* максимальный размер вводимой строки */

int max; /* длина максимальной из просмотренных строк */
char line[MAXLINE]; /* текущая строка */
char longest[MAXLINE]; /* самая длинная строка */

int getline(void);
void copy(void);

/* печать самой длинной строки: специализированная версия */
main()
{
    int len;
    extern int max;
    extern char longest[];
    max = 0;
    while ((len = getline()) > 0)
        if (len > max) {
            max = len;
            copy();
        }
    if (max > 0) /* была хотя бы одна строка */
        printf(“%s”, longest);
    return 0;
}

/* getline: специализированная версия */
int getline(void)
{
    int c, i;
    extern char line[];
    for (i = 0; i < MAXLINE-1 
        && (c=getchar()) != EOF && c != '\n'; ++i)
            line[i] = c;
    if(c == '\n') {
        line[i]= c;
         ++i;
    }
    line[i] = '\0';
    return i;
}

/* copy: специализированная версия */
void copy(void)
{
    int i;
    extern char line[], longest[];

    i = 0;
    while ((longest[i] = line[i]) != '\0')
        ++i;
}
```
Внешние переменные для `main`, `getline` и `copy` определяются в начале нашего примера, где им присваивается тип и выделяется память. Чтобы функция могла пользоваться внешней переменной, ей нужно прежде всего сообщить имя соответствующей переменной. Это можно сделать, например, задав объявление `extern`, которое по виду отличается от объявления внешней переменной только тем, что оно начинается с ключевого слова `extern`.

В некоторых случаях объявление `extern` можно опустить. Если определение внешней переменной в исходном файле расположено выше функции, где она используется, то в объявлении `extern` нет необходимости. Таким образом, в `main`, `getline` и `copy` объявления `extern` избыточны. Обычно определения внешних переменных располагают в начале исходного файла, и все объявления `extern` для них опускают.

Если же программа расположена в нескольких исходных файлах и внешняя переменная определена в файле1, а используется в файле2 и файлеЗ, то объявления `extern` в файле2 и файлеЗ обязательны, поскольку необходимо указать, что во всех трех файлах функции обращаются к одной и той же внешней переменной. На практике **обычно удобно собрать все объявления внешних переменных и функций в отдельный файл, называемый заголовочным (header -файлом)**, и помещать его с помощью `#include` в начало каждого исходного файла. В именах header-файлов по общей договоренности используется суффикс `.h`. В этих файлах, в частности в `<stdio.h>`, описываются также функции стандартной библиотеки.

Так как специализированные версии `getline` и `copy` не имеют аргументов, можно явно указать отсутствие аргументов, следует пользоваться словом `void`.

***Определение*** располагается в месте, где переменная создается и ей отводится память.

***Объявление*** помещается там, где фиксируется природа переменной, но никакой памяти для нее не отводится.

Следует отметить тенденцию все переменные делать внешними. Дело в том, что, как может показаться на первый взгляд, это приводит к упрощению связей - ведь списки аргументов становятся короче, а переменные доступны везде, где они нужны; однако они оказываются доступными и там, где не нужны. Так что чрезмерный упор на внешние переменные чреват большими опасностями - он приводит к созданию программ, в которых связи по данным не очевидны, поскольку переменные могут неожиданным и даже таинственным способом изменяться. Кроме того, такая программа с трудом поддается модификациям. Вторая версия программы поиска самой длинной строки хуже, чем первая, отчасти по этим причинам, а отчасти из-за нарушения общности двух полезных функций, вызванного тем, что в них вписаны имена конкретных переменных, с которыми они оперируют.

---
---

## Глава 2. Типы, операторы и выражения
Переменные и константы являются основными объектами данных, с которыми имеет дело программа. 

**Переменные** перечисляются в объявлениях, где устанавливаются их типы и, возможно, начальные значения. 

**Операции** определяют действия, которые совершаются с этими переменными.

**Выражения** комбинируют переменные и константы для получения новых значений. 

**Тип объекта** определяет множество значений, которые этот объект может принимать, и операций, которые над ними, могут выполняться.

Стандартом ANSI было утверждено значительное число небольших изменений и добавлений к основным типам и выражениям. Любой целочисленный тип теперь может быть со знаком, `signed`, и без знака, `unsigned`. 

Предусмотрен способ записи беззнаковых констант и шестнадцатеричных символьных констант. 

Операции с плавающей точкой допускаются теперь и с одинарной точностью. Введен тип `long double`, обеспечивающий повышенную точность. 

Строковые константы конкатенируются ("склеиваются”) теперь во время компиляции. 

Частью языка стали перечисления `enum`, формализующие для типа установку диапазона значений. 

Объекты для защиты их от каких-либо изменений разрешено помечать как `const`. 

### Имена переменных
Символ подчеркивания "_" считается буквой.

Обычно в программах на Си **малыми буквами** набирают переменные, а **большими** - именованные константы.

### Типы и размеры данных
`char` - единичный байт, который может содержать один символ из допустимого символьного набора;

`int` - целое, обычно отображающее естественное представление целых в машине; 

`float` - число с плавающей точкой одинарной точности;

`double` - число с плавающей точкой двойной точности.

Имеется также несколько квалификаторов, которые можно использовать вместе с указанными базовыми типами. Например, квалификаторы `short` (короткий) и `long` (длинный) применяются к целым:

```C
short int sh;
long int counter;
```

Чаще всего для представления целого, описанного с квалификатором `short`, отводится 16 бит, с квалификатором `long` - 32 бита.

Квалификаторы `signed` (со знаком) или `unsigned` (без знака) можно применять к типу `char` и любому целочисленному типу. Значения `unsigned` всегда положительны или равны нулю и подчиняются законам арифметики по модулю 2 в степени n, где n - количество бит в представлении типа. 

Так, если значению `char` отводится 8 битов, то `unsigned char` имеет значения в диапазоне от 0 до 255, a `signed char` – от -128 до 127 (в машине с двоичным дополнительным кодом). 

Тип `long double` предназначен для арифметики с плавающей точкой повышенной точности. 

`float`, `double` и `long double` могут представляться одним размером, а могут - двумя или тремя разными размерами.

---
### Константы
Целая константа, например 1234, имеет тип `int`. Константа типа `long` завершается буквой l или L, например 123456789L: слишком большое целое, которое невозможно представить как `int`, будет представлено как `long`. Беззнаковые константы заканчиваются буквой u или U, а окончание ul или UL говорит о том, что тип константы - `unsigned long`.

Константы с плавающей точкой имеют десятичную точку (123.4), или экспоненциальную часть (1е-2), или же и то и другое. Если у них нет окончания, считается, что они принадлежат к типу `double`. Окончание f или F указывает на тип `float`, а l или L - на тип `long double`.

***Символьная константа*** есть целое, записанное в виде символа, обрамленного одиночными кавычками, например `'x'`. Значением символьной константы является числовой код символа из набора символов на данной машине. Например, символьная константа '0' в кодировке ASCII имеет значение 48, которое никакого отношения к числовому значению 0 не имеет. 

Некоторые символы в символьных и строковых константах записываются с помощью эскейп-последовательностей, например `\n` (символ новой строки); такие последовательности изображаются двумя символами, но обозначают один. Кроме того, произвольный восьмеричный код можно задать в виде

`'\ooo'` где ооо - одна, две или три восьмеричные цифры (0 ... 7) или

`'\xhh'` где hh - одна, две или более шестнадцатеричные цифры (0...9, а...f, A...F). 

Полный набор эскейп-последовательностей таков:
```bash
\а сигнал-звонок
\b возврат-на-шаг (забой) 
\f перевод-страницы
\n новая-строка
\r возврат-каретки
\t горизонтальная-табуляция 
\v вертикальная-табуляция 
\\ обратная наклонная черта 
\? знак вопроса
\' одиночная кавычка
\" двойная кавычка
\ooo восьмеричный код 
\xhh шестнадцатеричный код
```
Символьная константа `'\0'` - это символ с нулевым значением, так называемый символ `null`. Вместо просто 0 часто используют запись `'\0'`, чтобы подчеркнуть символьную природу выражения, хотя и в том и другом случае запись обозначает нуль.

***Константные выражения*** - это выражения, оперирующие только с константами. Такие выражения вычисляются во время компиляции, а не во время выполнения

```C
#define MAXLINE 1000
char line[MAXLINE+1];
```
или в

```C
#define LEAP 1 /* in leap years - в високосные годы */
int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31];
```
***Строковая константа, или строковый литерал***, - это ноль или более символов, заключенных в двойные кавычки, 

`"Я строковая константа”` или 
`""   /* пустая строка */`

Фактически строковая константа — это массив символов. Во внутреннем представлении строки в конце обязательно присутствует нулевой символ '\0' , поэтому памяти для строки требуется на один байт больше, чем число символов, расположенных между двойными кавычками. Это означает, что на длину задаваемой строки нет ограничения, но чтобы определить ее длину, требуется просмотреть всю строку. Функция `strlen(s)` вычисляет длину строки `s` без учета завершающего ее символа `'\0'` . Ниже приводится наша версия этой функции:

```C
/* strlen: возвращает длину строки s */ int strlen(char s[])
{
int i;
    i = 0;
    while (s[i] != '\0')
        ++i;
    return i;
}
```

Функция `strlen` и некоторые другие, применяемые к строкам, описаны в стандартном заголовочном файле `<string.h>`.

Помните, что символьная константа и строка, содержащая один символ, не одно и то же: 'x' не то же самое, что "x". Запись 'x' обозначает целое значение, равное коду буквы x из стандартного символьного набора, а запись "x" - массив символов, который содержит один символ (букву x) и '\0'.

В Си имеется еще один вид константы - константа перечисления. Перечисление - это список целых констант

```C
enum boolean {NO, YES};
```
Первое имя в `enum` имеет значение 0, следующее - 1 и т.д. (если для значений констант не было явных спецификаций). 

Средство `enum` обеспечивает удобный способ присвоить константам имена, причем в отличие от `#define` значения констант при этом способе могут генерироваться автоматически. Хотя разрешается объявлять переменные типа `enum`, однако компилятор не обязан контролировать, входят ли присваиваемые этим переменным значения в их тип. Но сама возможность такой проверки часто делает `enum` лучше, чем `#define`. Кроме того, отладчик получает возможность печатать значения переменных типа enum в символьном виде.

---
### Объявления
Объявление специфицирует тип и содержит список из одной или нескольких переменных этого типа

```C
int lower, upper, step; char c, line[1000];
```

Переменные можно распределять по объявлениям произвольным образом, так что указанные выше списки можно записать и в следующем виде:

```C
int lower;
int upper;
int step;
char c;
char line[1000];
```

В объявлении переменная может быть инициализирована

```C
char esc = '\\';
int i = 0;
int limit = MAXLINE+1;
float eps = 1.0e-5;
```
**Инициализация неавтоматической (не локальной) переменной** осуществляется только один раз - перед тем, как программа начнет выполняться, при этом начальное значение должно быть константным выражением. 

Явно **инициализируемая автоматическая (локальная) переменная** получает начальное значение каждый раз при входе в функцию или блок, ее начальным значением может быть любое выражение. Внешние и статические переменные по умолчанию получают нулевые значения. Автоматические переменные, явным образом не инициализированные, содержат неопределенные значения ("мусор”).

К любой переменной в объявлении может быть применен квалификатор `const` для указания того, что ее значение далее не будет изменяться.

```C
const double е = 2.71828182845905; 
const char msg[] = "предупреждение: ";
```
Применительно к массиву квалификатор `const` указывает на то, что ни один из его элементов не будет меняться. Указание `const` можно также применять к аргументу- массиву, чтобы сообщить, что функция не изменяет этот массив:

```C
int strlen(const char[]);
```

---
### Арифметические операторы
Оператор деления по модулю `%`. Деление целых сопровождается отбрасыванием дробной части, какой бы она ни была. 

Выражение  `x % y` дает остаток от деления `x` на `y` и, следовательно, нуль, если `x` делится на `y` нацело. Например, год является високосным, если он делится на 4, но не делится на 100. Кроме того, год является високосным, если он делится на 400. 

```C
if ((year % 4 == 0 && year % 100 !=0 || year % 400 == 0) { 
printf("%d високосный год\n", year);
}
else {
printf("%d невисокосный год\n", year);
}
```
Оператор `%` к операндам типов `float` и `double` не применяется. 

---
Бинарные операторы `+` и `-` имеют одинаковый приоритет, который ниже приоритета операторов `*`, `/` и `%`, который в свою очередь ниже приоритета унарных операторов `+` и `-`. Арифметические операции одного приоритетного уровня выполняются ***слева направо***.

### Приоритеты и очередность вычислений операторов
Операторы, перечисленные на одной строке, имеют одинаковый приоритет: строки упорядочены по убыванию приоритетов. 

Оператор `()` относится к вызову функции. Операторы `->` и ` . ` (точка) обеспечивают доступ к элементам структур, и оператор `sizeof` (размер объекта).
```bash
()  []  ->  .

!   ~   ++   --   +   -   *   &   (type)   sizeof

*   /   %

+   -

<<  >>

<   <=   >   >=

==   !=

&  (побитовое И)

^  (побитовое исключающее ИЛИ)

|  (побитовое ИЛИ)

&&  (И)

||  (ИЛИ)

?: (тернарный оператор, имеющий три операнда )

=   +=   -=   *=   /=   %=   &=   ^=   |=   <<=   >>= (операторы присваивания)

,
```

---
### Преобразования типов
Неявные арифметические преобразования, как правило, осуществляются естественным образом. В общем случае, когда оператор вроде `+` или `*` с двумя операндами (бинарный оператор) имеет разнотипные операнды, прежде чем операция начнет выполняться, "низший” тип повышается до "высшего”. Результат будет иметь высший тип. 

Если же в выражении нет беззнаковых операндов, можно удовлетвориться следующим набором неформальных правил:
- Если какой-либо из операндов принадлежит типу `long double`, то и другой приводится к `long double`.
- В противном случае, если какой-либо из операндов принадлежит типу `double`, то и другой приводится к `double`.
- В противном случае, если какой-либо из операндов принадлежит типу `float`, то и другой приводится к `float`.
- В противном случае операнды типов `char` и `short` приводятся к `int`.
- И наконец, если один из операндов типа `long`, то и другой приводится к `long`.

Заметим, что операнды типа `float` не приводятся автоматически к типу `double`; в этом данная версия языка отличается от первоначальной. Вообще говоря, математические функции, аналогичные собранным в библиотеке `<math.h>`, базируются на вычислениях с двойной точностью. В основном `float` используется для экономии памяти на больших массивах и не так часто - для ускорения счета на тех машинах, где арифметика с двойной точностью слишком дорога с точки зрения расхода времени и памяти.

Правила преобразования усложняются с появлением операндов типа `unsigned`. Проблема в том, что сравнения знаковых и беззнаковых значений зависят от размеров целочисленных типов, которые на разных машинах могут отличаться.

Так как аргумент в вызове функции есть выражение, при передаче его функции также возможно преобразование типа. При отсутствии прототипа (функции аргументы тина `char` и `short` переводятся в `int`, a `float` - в `double`. Вот почему мы объявляли аргументы типа `int` или `double` даже тогда, когда в вызове функции использовали аргументы типа `char` или `float`.

И наконец, для любого выражения можно явно ("насильно”) указать преобразование его типа, используя унарный оператор, называемый приведением. Конструкция вида

```bash
(имя-типа) выражение
```
приводит выражение к указанному в скобках типу. Смысл операции приведения можно представить себе так: выражение как бы присваивается некоторой переменной указанного типа, и эта переменная используется вместо всей конструкции. 

Например, библиотечная функция `sqrt` ожидает аргумента типа `double` и выдает бессмыслицу, если случайно получает аргумент неподходящего типа. (Функция `sqrt` объявлена в заголовочном файле `<math.h>`.) Если `n` — целочисленная переменная, ее можно вначале привести к типу `double`, а затем уже передавать в функцию: 

```C
sqrt((double) n)
```
Обратите внимание, что приведение типа порождает новое значение нужного типа, никак не изменяя исходную переменную `n`. Приоритет оператора приведения столь же высок, как и любого унарного оператора.

Когда аргументы описаны в прототипе функции, как тому и следует быть, при вызове функции нужное преобразование выполняется автоматически. Так, при наличии прототипа функции `sqrt`:

`double sqrt(double);`
перед обращением к sqrt в присваивании

`root2 = sqrt(2);`
целое 2 будет переведено в значение `double 2.0` автоматически без явного указания операции приведения.

---
### Операторы инкремента и декремента
Необычность операторов `++` и `--` в том, что их можно использовать и как ***префиксные*** (помещая перед переменной: `++n`), и как ***постфиксные*** (помещая после переменной: `n++`) операторы. В обоих случаях значение `n` увеличивается на 1, но выражение `++n` увеличивает `n` до того, как его значение будет использовано, а `n++` - после того. Предположим, что `n` содержит 5:

`x = n++;`
установит `x` в значение 5, а

`x = ++n;`
установит `x` в значение 6. 
И в том и другом случае `n` станет равным 6. Операторы инкремента и декремента можно применять только к переменным. Выражения вроде `(i+j)++` недопустимы.

Cуществуют ситуации, когда требуется оператор вполне определенного типа. Например, рассмотрим функцию `squeeze(s, c)`, которая удаляет из строки `s` все символы, совпадающие с `c`:

```C
/* squeeze: удаляет все c из s*/ void squeeze(char s[], int с) {
    int i, j;
    for (i = j =0; s[i] != '\0'; i++)
        if (s[i] != c) {
            s[j++] = s[i];
            }
        s[i] = '\0';
}
```

Каждый раз, когда встречается символ, отличный от `c`, он копируется в текущую j-ю позицию, и только после этого переменная `j` увеличивается на 1, подготавливаясь таким образом к приему следующего символа. Это в точности совпадает со следующими действиями:

```C
if (s[i] != с) {
s[j] = s[i];
j++; }
```

Другой пример - функция `getline`, которая нам известна по главе 1. Приведенную там запись

```C
if (c =='\n') {
    s[i] = c;
++i; }
```
можно переписать более компактно:

```C
if (с == '\n')
s[i++] = с;
```

В качестве третьего примера рассмотрим стандартную функцию `strcat(s,t)`, которая строку `t` помещает в конец строки `s`. 

```C
/* strcat: помещает t в конец s; s достаточно велика */ 
void strcat (char s[], char t[])
{
int i, j;
i = j = 0;
while (s[i] != '\0') /* находим конец s */ {
   i++;
   }
while ((s[i++] = t[j++]) != '\0') /* копируем t */{
    ; 
  }
}
```
При копировании очередного символа из `t` в `s` постфиксный оператор ++ применяется и к `i`, и к `j`, чтобы на каждом шаге цикла переменные `i` и `j` правильно отслеживали позиции перемещаемого символа.

---
### Побитовые операторы
В Си имеются шесть операторов для манипулирования с битами. Их можно применять только к целочисленным операндам, т. е. к операндам типов `char`, `short`, `int` и `long`, знаковым и беззнаковым.     

`&` - побитовое И      
`|` - побитовое ИЛИ       
`^` - побитовое исключающее ИЛИ. << - сдвиг влево.      
`>>` - сдвиг вправо.     
`~` - побитовое отрицание (унарный).     

Оператор ` & ` (***побитовое И***) часто используется для обнуления некоторой группы разрядов. Например

`n = n & 0177;`
обнуляет в `n` все разряды, кроме младших семи.

Оператор ` | ` (***побитовое ИЛИ***) применяют для установки разрядов; так,

`x = x | SET_ON;`
устанавливает единицы в тех разрядах `x`, которым соответствуют единицы в `SET_ON`.

Оператор ` ^ ` (***побитовое исключающее ИЛИ***) в каждом разряде установит 1, если соответствующие разряды операндов имеют различные значения, и 0, когда они совпадают.

Поразрядные операторы `&` и `|` следует отличать от логических операторов && и ||, которые при вычислении слева направо дают значение истинности. 
Например, если `x` равно 1, а `y` равно 2, то `x & y` даст нуль, а `x && y` - единицу.

Операторы `<<` и `>>` сдвигают влево или вправо свой левый операнд на число битовых позиций, задаваемое правым операндом, который должен быть неотрицательным. 
Так, `x << 2` сдвигает значение `x` влево на 2 позиции, заполняя освобождающиеся биты нулями, что эквивалентно умножению `x` на `4`. 

Сдвиг вправо беззнаковой величины всегда сопровождается заполнением освобождающихся разрядов нулями. Сдвиг вправо знаковой величины на одних машинах происходит с распространением знака ("арифметический сдвиг”), на других - с заполнением освобождающихся разрядов нулями ("логический сдвиг”).

Унарный оператор ` ~ ` поразрядно "обращает” целое т. е. превращает каждый единичный бит в нулевой и наоборот. Например
`x = x & ~077`

обнуляет в `x` последние 6 разрядов. Заметим, что запись x & ~077 не зависит от длины слова, и, следовательно, она лучше, чем x & 0177700, поскольку последняя подразумевает, что x занимает 16 битов. Не зависимая от машины форма записи ~077 не потребует дополнительных затрат при счете, так как ~077 - константное выражение, которое будет вычислено во время компиляции.

Для иллюстрации некоторых побитовых операций рассмотрим функцию `getbits(x, p, n)`, которая формирует поле в `n` битов, вырезанных из `x`, начиная с позиции `p`, прижимая его к правому краю. Предполагается, что 0-й бит - крайний правый бит, а `n` и `p` осмысленные положительные числа. Например, `getbits(x,4,3)` вернет в качестве результата 4, 3 и 2-й биты значения `x`, прижимая их к правому краю. Вот эта функция:

```C
/* getbits: получает n бит, начиная с p-й позиции */ unsigned getbits(unsigned x, int p, int n)
{
    return (x >> (p+1-n)) & ~(~0 << n);
}
```
Выражение `x >> (р+1-n)` сдвигает нужное нам поле к правому краю. Константа `~0` состоит из одних единиц, и ее сдвиг влево на `n` бит `(~0 << n)` приведет к тому, что правый край этой константы займут `n` нулевых разрядов. Еще одна операция побитовой инверсии `~` позволяет получить справа `n` единиц.

---
### Операторы и выражения присваивания
***ор*** - оператор присваивания. Если выр1 и выр2 - выражения, то 

```
выр1 op= выр2
```
Эквивалентно

```
выр1 = (выр1) op (выр2)
```
с той лишь разницей, что выр1 вычисляется только один раз. Обратите внимание на скобки вокруг выр2:

```
x *= y + 1
```
эквивалентно

```
x = x * (y + 1)
```
В качестве примера приведем функцию `bitcount`, подсчитывающую число единичных битов в своем аргументе целочисленного типа.

```C
/* bitcount: подсчет единиц в х */ int bitcount(unsigned х)
{
int b;
for (b = 0; х != 0; x >>= 1)
        if (x & 01)
            b++;
return b; 
}
```

Объявление аргумента `x` как `unsigned` гарантирует, что при правом сдвиге освобождающиеся биты будут заполняться нулями, а не знаковым битом.

Помимо краткости операторы присваивания обладают тем преимуществом, что они более соответствуют тому, как человек мыслит. 
Мы говорим "прибавить 2 к i" или "увеличить i на 2", а не "взять i, добавить 2 и затем вернуть результат в i", так что выражение `i+=2` лучше, `чем i=i+2`.  

Типом и значением любого выражения присваивания являются тип и значение его левого операнда после завершения присваивания.

---

Условное выражение, написанное с помощью ***тернарного (т. е. имеющего три операнда) оператора*** `"? : "`

```
выр1 ? выр2 : выр3
```
Первым вычисляется выражение выр1. Если его значение не ноль (истина), то вычисляется выражение выр2, и значение этого выражения становится значением всего условного выражения. В противном случае вычисляется выражение выр3 и его значение становится значением условного выражения. Следует отметить, что из выражений выр2 и выр3 вычисляется только одно из них. Таким образом, чтобы установить в z большее из a и b, можно написать

```C
z = (a > b) ? a : b;    /* z = max(a, b) */
```
Если выр2 и
выр3 принадлежат разным типам, то тип результата определяется правилами преобразования. Например, если `f` имеет тип `float`, а `n` - тип `int`, то типом выражения

```C
(n > 0) ? f : n
```
будет `float` вне зависимости от того, положительно значение `n` или нет.

---



