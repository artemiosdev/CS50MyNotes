

Алгоритм - набор действий для пошагового решения проблемы
Wiki [Algorithm](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC#.D0.9C.D0.B0.D1.88.D0.B8.D0.BD.D0.B0_.D0.A2.D1.8C.D1.8E.D1.80.D0.B8.D0.BD.D0.B3.D0.B0) 

"Hello World" на языке Си

```C
#include <stdio.h>
int main(void) {
  printf("Hello World\n");
  return 0;
}
```

Программы в Cи состоят из функций, а те — из операторов и переменных. **Функция** — это кусок кода, в котором уже есть или подаются какие-то данные, а какие-то данные получаются в результате её исполнения. 

`printf()` из стандартной библиотеки `stdio` выводит любую строку на экран. Строки заключаются в двойные кавычки, а символ `\n` означает перевод курсора на новую строку. 

**Компилятор** - принимает на вход исходный код, и преобразует его в объектный код, т.е в 0 и 1, машинный код понятный компьютеру.

`#include <stdio.h>` - дает доступ к библиотеке функций

Строка `#include` делает очень важную вещь: она подключает библиотеки уже написанного кода к вашей программе. 

Имя подключенной библиотеки идет в угловых скобках `(<>)` и носит расширение `(.h)`. Если бы не было библиотек, то любое, самое элементарное действие, пришлось бы каждый раз описывать снова и снова. Подключенная нами библиотека содержит функции ввода/вывода. Именно она позволяет нам использовать функцию `printf()` для вывода на экран. То есть, если бы мы не написали строку `#include <stdio.h>`, но оставили в теле программы функцию `printf ()`, при попытке запуска мы бы получили ошибку! Потому что без этой библиотеки компилятор не знает, что такое `printf()`. 

Есть библиотеки стандартные, они составляют словарный запас языка. Функция `printf()` не встроена в компьютер, но входит в стандартную библиотеку языка Cи

В технических терминах, библиотека — это двоичный файл, полученный путем объединения в коллекцию объектных файлов, используя компоновщик. **Объектные файлы** — это те файлы с расширением `(*.o)`, которые вы получаете при компиляции приложений

`printf("")` - функция для печати

```bash
$ ./hello
Hello World
```

`clang [name]` - один из компиляторов. Для компиляции можно также использовать уже знакомую вам программу `make`. По сути, она вызывает `clang` с определенными аргументами командной строки. 

`make [name]` - команда компилирует указанный файл `name`

`./a.out` - название первой скомпилированной программы по умолчанию

```bash
$ clang hello.c
$ ./hello
Hello World
$ ./a.out
Hello World
```

```bash
$ make hello
clang   hello.o   -o hello
```

```C
#include<stdio.h>

int main(void)
{
for (int i = 0; i < 10; i++)
printf("hello, world!\n");
}
```

```C
#include <stdio.h>

int main() {
int a, b, c;
    a = 5;
    b = 7;
    c = a + b;
    printf("%d + %d = %d\n", a, b, c);
    return 0;
}
```

Например, библиотека строк [string.h](https://ru.wikipedia.org/wiki/String.h), где описаны операции со строками (определение длины, сложение и прочее) 


255 в двоичной 11111111, так как начало счета с 0 и до 255 = 256 чисел

256 в двоичной 100000000

---

[**Жадный алгоритм**](https://ru.wikipedia.org/wiki/%D0%96%D0%B0%D0%B4%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC) (*Greedy algorithm*) — алгоритм, заключающийся в принятии локально [оптимальных решений](https://ru.wikipedia.org/wiki/Оптимальное_решение) на каждом этапе, допуская, что конечное решение также окажется оптимальным.

Если глобальная оптимальность алгоритма имеет место практически всегда, его обычно предпочитают другим методам оптимизации, таким как [динамическое программирование](https://ru.wikipedia.org/wiki/Динамическое_программирование).

(

**Динамическое программирование** — способ решения сложных задач путём разбиения их на более простые подзадачи. Он применим к задачам с оптимальной подструктурой, выглядящим как набор перекрывающихся подзадач, сложность которых чуть меньше исходной. В этом случае время вычислений, по сравнению с «наивными» методами, можно значительно сократить.

Ключевая идея в динамическом программировании достаточно проста. Как правило, чтобы решить поставленную задачу, требуется решить отдельные части задачи (подзадачи), после чего объединить решения подзадач в одно общее решение. Часто многие из этих подзадач одинаковы. Подход динамического программирования состоит в том, чтобы решить каждую подзадачу только один раз, сократив тем самым количество вычислений. Это особенно полезно в случаях, когда число повторяющихся подзадач экспоненциально велико.

Метод *динамического программирования сверху* — это простое запоминание результатов решения тех подзадач, которые могут повторно встретиться в дальнейшем. *Динамическое программирование снизу* включает в себя переформулирование сложной задачи в виде [рекурсивной](https://ru.wikipedia.org/wiki/Рекурсия) последовательности более простых подзадач.

)

Общего критерия оценки применимости жадного алгоритма для решения конкретной задачи не существует, однако для задач, решаемых жадными алгоритмами, характерны две особенности:

**Принцип жадного выбора** - если последовательность локально оптимальных выборов даёт глобально оптимальное решение. В типичном случае доказательство оптимальности следует такой схеме:

1. Доказывается, что жадный выбор на первом шаге не закрывает пути к оптимальному решению: для всякого решения есть другое, согласованное с жадным выбором и не хуже первого.
2. Показывается, что подзадача, возникающая после жадного выбора на первом шаге, аналогична исходной.
3. Рассуждение завершается по индукции.

**Оптимальность для подзадач** - если оптимальное решение задачи содержит в себе оптимальные решения для всех её подзадач.

---
### Размен монет
Так, например, сумму в 24 копейки монетами в 1, 5 и 7 коп. жадный алгоритм разменивает так: 7 коп. — 3 шт., 1 коп. — 3 шт., в то время как правильное решение — 7 коп. — 2 шт., 5 коп. — 2 шт.

Представим, что кассир должен покупателю сдачу в 41 цент, а у него на поясе есть цилиндры с монетками для сдачи номиналом в 25, 10, 5 и 1 цент. Руководствующийся «жадным» алгоритмом кассир сразу же захочет выдать максимум, на первом же шаге. На этом шаге оптимальным или наилучшим решением будет выдать 25 пенсов. 41-25 = 16. Осталось выдать 16 пенсов. Очевидно, 25 пенсов слишком много, значит, остается 10. 16-10 = 6. Теперь выдаем по тому же принципу 5 пенсов, и затем — 1. Таким образом, покупатель получит всего четыре монеты номиналом 25, 10, 5 и 1 пенс.

---

### HelloWorld на Java
```java
public class HelloWorld {
   public static void main(String[] args) {
       // Выводим Hello World в консоль.
       System.out.println("Hello, World");
   }
}
```
---
---
---

## **The C programming Language**, **Second Edition, Brian W. Kernighan, Dennis M. Ritchie**

### Глава 1. Обзор языка
Программа на Си, каких бы размеров она ни была, состоит из *функций и переменных*. Функции содержат *инструкции*, описывающие вычисления, которые необходимо выполнить, а переменные хранят значения, используемые в процессе этих вычислений.

"Hello World" на языке Си

```C
#include <stdio.h>
int main(void) {
  printf("Hello World\n");
  return 0;
}
```
Приведенная программа - это функция с именем `main`. Обычно вы вольны придумывать любые имена для своих функций, но “main" - особое имя: любая программа начинает свои вычисления с первой инструкции функции `main`.

```C
#include <stdio.h>
```
сообщает компилятору, что он должен включить информацию о стандартной библиотеке ввода-вывода. Эта строка встречается в начале многих исходных файлов Си-программ.

Один из способов передачи данных между функциями состоит в том, что функция при обращении к другой функции передает ей список значений, называемых **аргументами**. Этот список берется в скобки и помещается после имени функции. В нашем примере `main` определена как функция, которая не ждет никаких аргументов, что отмечено пустым списком (void).

```C
printf("Hello World\n");
```

Функция `main` вызывает библиотечную функцию `printf` для печати заданной последовательности символов; `\n` - символ новой строки. Символ новой строки никогда не вставляется автоматически.

Функция `printf` - это библиотечная функция, которая в данном случае напечатает последовательность символов, заключенную в двойные кавычки.

```C
#include <stdio.h>
/* печать таблицы температур по Фаренгейту
и Цельсию для fahr = 0, 20, ..., 300 */
main()
{
    int fahr, celsius;
    int lower, upper, step;

    lower = 0; /* нижняя граница таблицы температур */
    upper = 300; /* верхняя граница */
    step = 20;  /* шаг */

    fahr = lower;
    while (fahr <= upper) {
        celsius = 5 * (fahr-32) / 9;
        printf(“%d\t%d\n”, fahr, celsius);
        fahr = fahr + step;
    }
}
```
```bash
0	-17
20	-6
40	4
60	15
80	26
100	37
120	48
140	60
160	71
180	82
200	93
220	104
240	115
260	126
280	137
300	148
```

В Си любая переменная должна быть объявлена раньше, чем она будет использована; обычно все переменные объявляются в начале функции перед первой исполняемой инструкцией. В объявлении описываются свойства переменных. Оно состоит из названия типа и списка переменных, например:

```C
int fahr, celsius;
int lower, upper, step;
```
Тип `int` означает, что значения перечисленных переменных есть целые, в отличие от него тип `float` указывает на значения с плавающей точкой, т. е. на числа, которые могут иметь дробную часть.

Числа типа `int` бывают как 16-разрядные (лежат в диапазоне от -32768 до 32767), так и 32-разрядные. Числа типа `float` обычно представляются 32-разрядными словами, имеющими по крайней мере 6 десятичных значащих цифр (лежат приблизительно в диапазоне от 10-38 до 10+38.

Помимо `int` и `float` в Си имеется еще несколько базовых типов для данных, это:

`char` - символ-единичный байт;
`short` - короткое целое;
`long` - длинное целое;
`double` - с плавающей точкой с двойной точностью.

| Тип |	Определение |	Диапазон значений |	Размер в байтах |
| :---------: | :---------- | :---------- | :---------: |
|int |	Целые числа |	-2 147 483 648 до 2 147 483 647	|  4|
|short int |	Короткие целые числа | -32 768 до 32 767	|  2|
|float |  Дробные числа (числа с плавающей запятой)	| -2 147 483 648.0 до 2 147 483 647.0	| 4 (32 bit) |
|double |	Дробные числа двойной точности	| -9 223 372 036 854 775 808 .0 до 9 223 372 036 854 775 807.0 | 8|
|long float |	Длинные дробные числа (зависит от системы) |	-9 223 372 036 854 775 808 .0 до 9 223 372 036 854 775 807.0 | 8|
|char | Символы | ‘Q’; ‘f’; ‘:’; ‘@’ | 1|
|string | Строковые данные | строки, которые можно закодировать в 32 разрядах или меньше | 4|
|bool | Булевы выражения | true; false | 1|

Программа выполняет вычисления по формуле `°С = (5/9)(°F-32`) и печатает таблицу соответствия температур по Фаренгейту температурам по Цельсию

```
celsius = 5 * (fahr-32) / 9;
```
Причина, по которой мы сначала умножаем на 5 и затем делим на 9, а не сразу умножаем на 5/9, связана с тем, что в Си, как и во многих других языках, деление целых сопровождается **отбрасыванием**, т. е. потерей дробной части. Так как 5 и 9 - целые, отбрасывание в 5/9 дало бы нуль, и на месте температур по Цельсию были бы напечатаны нули.

**Функция printf** - это универсальная функция форматного ввода-вывода. Ее первый аргумент - строка символов, в которой каждый символ `%` соответствует одному из последующих аргументов (второму, третьему, ...), а информация, расположенная за символом `%`, указывает на вид, в котором выводится каждый из этих аргументов. Например, `%d` специфицирует выдачу аргумента в виде целого десятичного числа, и инструкция

```C
printf(“%d\t%d\n”, fahr, celsius);
```
печатает целое `fahr`, выполняет табуляцию `(\t)` и печатает целое `celsius`.

В функции `printf` каждому спецификатору первого аргумента (конструкции, начинающейся с `%`) соответствует второй аргумент, третий аргумент и т. д. Спецификаторы и соответствующие им аргументы должны быть согласованы по количеству и типам: в противном случае напечатано будет не то, что нужно.


Например, 0°F на самом деле (с точностью до десятой) равно -17.8°С, а не -17. Чтобы получить более точные значения температур, нам надо пользоваться не целочисленной арифметикой, а арифметикой с плавающей точкой.

```C
#include <stdio.h>
/* печать таблицы температур по Фаренгейту и Цельсию для fahr = 0, 20, . .., 300; вариант с плавающей точкой   */
main()
{
    float fahr, celsius;
    int lower, upper, step;

    lower = 0;   /* нижняя граница таблицы температур */ 
    upper = 300; /* верхняя граница */ 
    step = 20;   /* шаг */

    fahr = lower;
    while (fahr <= upper) { 
        celsius = (5.0/9.0) * (fahr-32.0);
        printf(“%3.0f %6.1f\n”, fahr, celsius);
        fahr = fahr + step;
    }
}
```

`printf(“%3.0f %6.1f\n”, fahr, celsius);`
Спецификация *%3.0f* в *printf* определяет печать числа с плавающей точкой (в данном случае числа *fahr*) в поле шириной не более трех позиций без десятичной точки и дробной части. Спецификация *%6.1f* описывает печать другого числа (*celsius*) в поле из шести позиций с одной цифрой после десятичной точки

```bash
  0  -17.8
 20   -6.7
 40    4.4
 60   15.6
 80   26.7
100   37.8
120   48.9
140   60.0
160   71.1
180   82.2
200   93.3
220  104.4
240  115.6
260  126.7
280  137.8
300  148.9
```

`%d`	- печать десятичного целого.
`%6d`	- печать десятичного целого в поле из шести позиций.
`%f`	- печать числа с плавающей точкой.
`%6f` - печать числа с плавающей точкой в поле из шести позиций.
`%.2f`	- печать числа с плавающей точкой с двумя цифрами после десятичной точки.
`%6.2f`	- печать числа с плавающей точкой и двумя цифрами после десятичной точки в поле из шести позиций.
Кроме того, printf допускает следующие спецификаторы: `%o` для восьмеричного числа; `%x` для шестнадцатеричного числа; `%c` для символа; `%s` для строки символов и `%%` для самого %.

Упражнение 1.4. Напишите программу, которая будет печатать таблицу соответствия температур по Цельсию температурам по Фаренгейту.

```C
#include <stdio.h>
main()
{
    float fahr, celsius;
    int lower, upper, step;

    lower = 0;   /* нижняя граница таблицы температур */ 
    upper = 300; /* верхняя граница */ 
    step = 20;   /* шаг */

    celsius = lower;
          printf("Таблица\n");
    while (celsius <= upper) { 
        fahr = (9.0 * celsius) / 5.0 + 32.0;
        printf("%3.0f %6.0f\n", celsius, fahr);
        celsius = celsius + step;
    }
}
```
```bash
Таблица 
  0     32
 20     68
 40    104
 60    140
 80    176
100    212
120    248
140    284
160    320
180    356
200    392
220    428
240    464
260    500
280    536
300    572
```

---
### Инструкция for
Видоизменим нашу программу преобразования температур:

```C
#include <stdio.h>
/* печать таблицы температур по Фаренгейту и Цельсию */
main()
{
    int fahr;
    for (fahr = 0; fahr <= 300; fahr = fahr + 20)
        printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));
}
```
Выражение, вычисляющее температуру по Цельсию, теперь задано третьим аргументом функции `printf`, а не в отдельной инструкции присваивания.

Последнее изменение является примером применения общего правила: **в любом контексте, где возможно использовать значение переменной какого-то типа, можно использовать более сложное выражение того же типа**. Так, на месте третьего аргумента функции `printf` согласно спецификатору `%6.1f` должно быть значение с плавающей точкой, следовательно, здесь может быть любое выражение этого типа.

---
### Именованные константы
Строка `#define` определяет символьное имя, или именованную константу, для заданной строки символов:

```c
#define имя подставляемый-текст
```
С этого момента при любом появлении имени оно будет заменяться на соответствующий ему подставляемый-текст.

```C
#include <stdio.h>

#define LOWER 0   /* нижняя граница таблицы */
#define UPPER 300 /* верхняя граница */
#define STEP 20   /* размер шага */

/* печать таблицы температур по Фаренгейту и Цельсию */
main()
{
    int fahr;
    for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
        printf(“%3d %6.1f\n”, fahr, (5.0/9.0)*(fahr-32));
}
```

LOWER, UPPER и STEP - именованные константы, а не переменные, поэтому для них нет объявлений. По общепринятому соглашению имена именованных констант набираются заглавными буквами, чтобы они отличались от обычных переменных, набираемых строчными. Заметим, что в конце `#define-строки` точка с запятой не ставится.

---
### `getchar` и `putchar
Стандартная библиотека включает несколько функций для чтения и записи одного символа. Простейшие из них - `getchar` и `putchar`. За одно обращение к `getchar` считывается следующий символ ввода из текстового потока, и этот символ выдается в качестве результата. Так, после выполнения

```C
c = getchar();
```
переменная `c` содержит очередной символ ввода. Обычно символы поступают с клавиатуры. 

Обращение к `putchar` приводит к печати одного символа. 

```C
putchar(c);
```
напечатает содержимое целой переменной `c` в виде символа (обычно на экране). Вызовы `putchar` и `printf` могут произвольным образом перемежаться. Вывод будет формироваться в том же порядке, что и обращения к этим функциям.

---
### Копирование файла
Программа, копирующая по одному символу с входного потока в выходной поток:

```C
    чтение символа
    while (символ не является признаком конца файла)
    вывод только что прочитанного символа
    чтение символа
```

```C
#include <stdio.h>
/* копирование ввода на вывод, 1-я версия */
main()
{
    int c;
    c = getchar();
    while (c != EOF) {
        putchar(c);
        c = getchar();
    }
}
```
Оператор отношения `!=` означает “не равно”

Каждый символ, вводимый с клавиатуры или появляющийся на экране, как и любой другой символ внутри машины, кодируется комбинацией битов. Тип `char` специально предназначен для хранения символьных данных, однако для этого также годится и любой целый тип. Мы пользуемся типом `int` и делаем это по одной важной причине, которая требует разъяснений.

Существует проблема: как отличить конец ввода от обычных читаемых данных. Решение заключается в том, чтобы функция getchar по исчерпании входного потока выдавала в качестве результата такое значение, которое нельзя было бы спутать ни `с` одним реальным символом. Это значение есть **EOF (аббревиатура от end of file - конец файла)**. Мы должны объявить переменную `c` такого типа, чтобы его “хватило” для представления всех возможных результатов, выдаваемых функцией `getchar`. Нам не подходит тип `char`, так как c должна быть достаточно “емкой”, чтобы помимо любого значения типа `char` быть в состоянии хранить и EOF. Вот почему мы используем `int`, а не `char`.

EOF - целая константа, определенная в `<stdio.h>`. Какое значение имеет эта константа - неважно, лишь бы оно отличалось от любого из возможных значений типа `char`. Использование именованной константы с унифицированным именем гарантирует, что программа не будет зависеть от конкретного числового значения, которое, возможно, в других Си-системах будет иным.

Цикл `while`, пересылая в `c` полученное от `getchar` значение, сразу же проверяет: не является ли оно “концом файла”. Если это не так, выполняется тело цикла `while` и печатается символ. По окончании ввода завершается работа цикла `while`, а тем самым и `main`.

---
### Подсчет символов
```C
#include <stdio.h>
/* подсчет вводимых символов; 1-я версия */ 
main()
{
    long nc;
    nc = 0;
    while (getchar() != EOF) {
        ++nc;
    printf(“%ld\n”, nc);
    }
}
```
Инструкция `++nc;` представляет новый оператор ` ++ `, который означает увеличить на единицу. Вместо этого можно было бы написать `nc=nc+1`, но ++nc короче, а часто и эффективнее. Существует аналогичный оператор ` -- `, означающий уменьшить на единицу. Операторы ` ++ ` и ` -- ` могут быть как префиксными `(++nc)`, так и постфиксными `(nc++)`. 

Программа подсчета символов накапливает сумму в переменной типа `long`. Целые типа long имеют не менее 32 битов. Хотя на некоторых машинах типы `int` и `long` имеют одинаковый размер, существуют, однако, машины, в которых `int` занимает 16 бит с максимально возможным значением 32767, а это - сравнительно маленькое число, и счетчик типа `int` может переполниться. Спецификация `%ld` в `printf` указывает, что соответствующий аргумент имеет тип `long`.

Возможно охватить еще больший диапазон значений, если использовать тип `double` (т. е. `float` с двойной точностью). Применим также инструкцию `for` вместо `while`, чтобы продемонстрировать другой способ написания цикла.

```C
#include <stdio.h>
/* подсчет вводимых символов; 2-й версия */
main()
{
    double nc;
    for (nc = 0; getchar() != EOF; ++nc) {
        ;
    printf(“%.0f\n”, nc);
    }
}
```
В `printf` спецификатор `%f` применяется как для `float`, так и для `double`; спецификатор `%.0f` означает печать без десятичной точки и дробной части (последняя в нашем случае отсутствует).

Тело указанного for-цикла пусто, поскольку кроме проверок и приращений счетчика делать ничего не нужно. Но правила грамматики Си требуют, чтобы for-цикл имел тело. Выполнение этого требования обеспечивает изолированная точка с запятой, называемая пустой инструкцией. 

---
### Подсчет строк
```C
#include <stdio.h>
/* подсчет строк входного потока */
main()
{
    int c, nl;
    nl = 0;
    while ((c = getchar()) != EOF){
        if (c == '\n')
            ++nl;
    printf(“%d\n”, nl);
    }
}
```
Тело цикла теперь образует инструкция `if`, под контролем которой находится увеличение счетчика `nl` на единицу. Инструкция `if` проверяет условие в скобках и, если оно истинно, выполняет следующую за ним инструкцию.

---
### Подсчет слов
Программа подсчитывает строки, слова и символы, причем под словом здесь имеется в виду любая строка символов, не содержащая в себе пробелов, табуляций и символов новой строки. Эта программа является упрощенной версией программы `wc` системы UNIX.

```bash
flyboroda@MacBook-Air-Artem ~ % cd Documents/MyGit/CS50MyNotes 
flyboroda@MacBook-Air-Artem CS50MyNotes % wc README.md 
     526    3291   35240 README.md
```
Программa выведет три числа, обозначающих количество строк, слов и байт введённой информации.

```C
#include <stdio.h>

#define IN 1	/* внутри слова */
#define OUT 0	/* вне слова */
/* подсчет строк, слов и символов */
main()
{
    int с, nl, nw, nc, state;
    state = OUT;
    nl = nw = nc = 0;
    while ((с = getchar()) != EOF) {
        ++nc;
        if (c == '\n')
            ++nl;
        if (c == ' ' || c == '\n' || c == '\t')
            state = OUT;
        else if (state == OUT) {
            state = IN;
            ++nw;
        }
    }
    printf(“%d %d %d\n”, nl, nw, nc);
}
```

Каждый раз, встречая первый символ слова, программа изменяет значение счетчика слов на 1. Переменная `state` фиксирует текущее состояние - находимся мы внутри или вне слова. Вначале ей присваивается значение `OUT`, что соответствует состоянию “вне слова”. Мы предпочитаем пользоваться именованными константами `IN` и `OUT`, а не собственно значениями 1 и 0, чтобы сделать программу более понятной.

Упражнение 1.12. Напишите программу, которая печатает содержимое своего ввода, помещая по одному слову на каждой строке.
```C
#include <stdio.h>
#define IN 1 //внутри слова
#define OUT 0 //вне слова

int main()
{
 int c, state;
 state = OUT;
 while ((c = getchar()) != EOF) {
  if ( c == ' ' || c == '\t' || c == '\n') {
   state = OUT;
  }
  else if (state == OUT) {
   putchar('\n');
   state = IN;
  }
  putchar(c);
 }
 return 0;
}
```
```
My name is Artem
My 
name 
is 
Artem
```

---
### Массивы
А теперь напишем программу, подсчитывающую по отдельности каждую цифру, символы-разделители (пробелы, табуляции и новые-строки) и все другие символы. Имеется двенадцать категорий вводимых символов. Удобно все десять счетчиков цифр хранить в массиве, а не в виде десяти отдельных переменных. Вот один из вариантов этой программы:

```C
#include <stdio.h>

/* подсчет цифр, символов-разделителей и прочих символов */
int main()
{
    int c, i, nwhite, nother;
    int ndigit[10];

    nwhite = nother = 0;
    for (i = 0; i < 10; ++i) {
        ndigit[i]= 0;
    }

    while ((c = getchar()) != EOF) {
        if (c >='0' && c <= '9') {
            ++ndigit[c - '0'];
        }
        else if (c == ' ' || c == '\n' || c == '\t') {
            ++nwhite;
        }
        else {
            ++nother;
        }
    }

    printf("цифры =");
    for (i = 0; i < 10; ++i) {
        printf("%d", ndigit[i]);
    }
    printf(", символы-разделители =%d, прочие =%d\n", nwhite, nother);
}
```
```bash
The C programming Language
цифры =0000000000, символы-разделители =4, прочие =23
```

Объявление `int ndigit[10];` - объявляет `ndigit` массивом из 10 значений типа `int`. В Си элементы массива всегда нумеруются начиная с нуля, так что элементами этого массива будут `ndigit[0], ndigit[1], ..., ndigit[9]`, что учитывается в for-циклах (при инициализации и печати массива).

По определению, значения типа `char` являются просто малыми целыми, так что переменные и константы типа `char` в арифметических выражениях идентичны значениям типа `int`. Это и естественно, и удобно; например, `c-'0'` есть целое выражение с возможными значениями от 0 до 9, которые соответствуют символам от '0' до '9', хранящимся в переменной `c`. Таким образом, значение данного выражения является правильным индексом для массива `ndigit`.


Упражнение 1.13. Напишите программу, печатающую гистограммы длин вводимых слов. Гистограмму легко рисовать горизонтальными полосами. 

```C
#include <stdio.h>
#define IN 1
#define OUT 0
/*печатает гистограммы длин вводимых слов*/
 
int main()
{
int c, state;
state = OUT;
 
while ((c = getchar()) != EOF)
{
    if (c != ' ' && c != '\n' && c != '\t')
    {
        state = IN;
        putchar('-');
    }
    else if (state == IN)
    {
        state = OUT;
        putchar('\n');
    }
}
    return 0;
}
```
Inputs: `The C programming Language Brian W. Kernighan, Dennis M. Ritchie`
Result:
```bash
---
-
-----------
--------
-----
--
----------
------
--
-------
```

---
or another decision 
```C
#include <stdio.h>
/*подсчет символов в словах и печатание горизонтальной гистограммы с количеством символов*/
#define IN 1 /*внутри слова*/
#define OUT 2 /*вне слова*/
 
int main()
{
int c, nc, state;
nc = 0; state = OUT;
 
while ((c = getchar()) != EOF) {
    if (c != ' ' && c != '\n' && c != '\t')
        {state = IN;++nc; /*когда внутри слова-вклячается счетчик символов*/
        putchar('-'); } /*печатаем горизонтальную гистограмму этого слова*/
    else if (state == IN){
        state = OUT; printf("%d",nc); /*когда слово закончилось-печатаем количество символов в этом слове*/
        putchar('\n'); nc = 0;} /*переходим на новую строку и обнуляем счетчик символов, иначе он будет печатать общее количество символов всех слов*/
}
    return 0;
}
```
Inputs: `The C programming Language Brian W. Kernighan, Dennis M. Ritchie`
Result:
```bash
---3
-1
-----------11
--------8
-----5
--2
----------10
------6
--2
-------7

```

----
or another decision 
```C
#include <stdio.h>
main()
{
        int c;
        while ((c=getchar()) != EOF) {
                if (c == ' ' || c == '\n' || c == '\t')
                        printf("\n");
                else
                        printf("_");
        }
}
```

Inputs: `The C programming Language Brian W. Kernighan, Dennis M. Ritchie`
Result:
```bash
___
_
___________
________
_____
__
__________
______
__
_______
```

---
Рисование вертикальными полосами - более трудная задача.

```C
#include <stdio.h>
/*программа печатающая вертикальную гистограмму вводимых символов в словах*/
#define IN 1 /*внутри слова*/
#define OUT 0/*вне слова*/
#define MAXWORDS 80 /*максимальное количество слов в нашей гистограмме 80*/
 
int main()
{
int i, j, c, state; /*i-индекс массива слов, j-количество символов в слове, с - вводимый символ, state - состояние переменной с ( IN - внутри слова, OUT - вне слова) */
int lenword [MAXWORDS], nextword, maxlen; /*счетчик массива слов,следующее слово,самое длинное слово*/
nextword = maxlen = 0;
for (i = 0; i < MAXWORDS; ++i)    /*инициализируем цикл*/
    lenword [i] = 0;
state = OUT;
 
while ((c = getchar())!= EOF && nextword < MAXWORDS) {
    if ( c == ' ' || c == '\n' || c == '\t'){    /*1.если сначала вводится символ-разделитель,то */
        if (state == IN){                        /*программа ничего не делает,т.к. не выполняется*/
            if (lenword [nextword] > maxlen)     /*условие state == IN;( у нас state == OUT)*/
                    maxlen = lenword [nextword]; /*2.если вводится любой другой символ,программа */
        ++nextword; state = OUT; }               /*переходит к else, state становится IN и включа*/
    }                                            /*ется счетчик lenword [0],т.е. счетчик первого */
    else {                                   /*слова массива*/
        if (state == OUT)                        /*3.при появлении на вводе символа-разделителя */
            state = IN;                          /*(условие state == IN на этот раз выполнено) */
            ++lenword [nextword];                /*проверяется условие lenword [0] > maxlen, оно */
            }    /*истинно и тогда maxlen = lenword [0]. 4.переменная nextword увеличивается на 1 */
          }      /* т.е. счетчик символов приобретает индекс 1-lenword[1],state присваивается OUT */
for (j = maxlen; j > 0; --j){    /* Печатание гистограммы. 1.Переменной j присваисается значение */
    for(i = 0; i < nextword; ++i){ /*самого длинного слова из введенных,т.е. maxlen,это будет */
        if (lenword[i] >= j)       /*высота нашей гистограммы. 2. Цикл внутри цикла for печатает */
            putchar('#');          /*строку начиная со счетчика первого слова lenword[0], если */
        else                       /*это не самое длинное слово то печатается пробел,цикл перехо-*/
                putchar(' ');      /*дит к следующему слову (++i) и каретка смещается на одно поле*/
                }                  /*вправо.Когда цикл доходит до самого длинного слова,то печатает*/
     putchar('\n') ;               /*#. 3.Когда "внутренний" цикл доходит до последнего слова*/
}                                  /*условие i < nextword перестает выполняться и цикл завершает свою работу и программа переходит к функции putchar('\n'),*/
        return 0;                  /*т.е. каретка принтера переходит на новую строку. 4.выполняется */
}                                  /* --j и запускается следующий цикл "наружного" цикла for. */
                                   /*5. когда j дойдет до нуля,условие j>0 перестанет выполняться и цикл прекратит работу.   Программа завершена.  */
                                   
```

Inputs: `The C programming Language Brian W. Kernighan, Dennis M. Ritchie`
Result:
```bash
  #       
  #   #   
  #   #   
  ##  #   
  ##  #  #
  ##  ## #
  ### ## #
  ### ## #
# ### ## #
# ########
##########
```

Упражнение 1.14. Напишите программу, печатающую гистограммы частот встречаемости вводимых символов.

```C
#include <stdio.h>
/* Задание 1,14 Гистограмма частот встречаемости введенных символов подсчитываются символы с ASCII-кодами от 0 до 255 */
int main(){
    int c;                          // переменная для ввода символов
    int i, j;                        // счетчики циклов
    int size = 255;           // размер массива
    int symbols[size];      // сам массив
 
    printf("Enter text: \n"); 
 
    /* заполняем массив нулями */
    for(i = 0; i < size; ++i)
        symbols[i] = 0;
 
    /* пока не достигнут конец файла, считываем символы и записываем их в массив*/
    while((c = getchar()) != EOF)
    {
        ++symbols[c];
 
        /* Если объем символов превысил размер массива, установить размер равным 255 */
        if(symbols[c] > size)
        {
            size = 255;
        }
    }
 
    /* выводим массив на печать, заменяя повторяющиеся символы на знак "#" */
    for(i = 0; i < size; i++)
    {
        if(symbols[i] > 0)
        {
                printf("Symbol: '%c' - ", i);
                for(j = 0; j < symbols[i]; ++j) { printf("#"); }
                printf("\n"); 
        }
    }
 
        return 0;
}
```

Inputs: `The C programming Language Brian W. Kernighan, Dennis M. Ritchie`
Result:
```bash
Enter text: 
Symbol: '
' - #
Symbol: ' ' - #########
Symbol: ',' - #
Symbol: '.' - ##
Symbol: 'B' - #
Symbol: 'C' - #
Symbol: 'D' - #
Symbol: 'K' - #
Symbol: 'L' - #
Symbol: 'M' - #
Symbol: 'R' - #
Symbol: 'T' - #
Symbol: 'W' - #
Symbol: 'a' - #####
Symbol: 'c' - #
Symbol: 'e' - #####
Symbol: 'g' - #####
Symbol: 'h' - ###
Symbol: 'i' - ######
Symbol: 'm' - ##
Symbol: 'n' - #######
Symbol: 'o' - #
Symbol: 'p' - #
Symbol: 'r' - ####
Symbol: 's' - #
Symbol: 't' - #
Symbol: 'u' - #
```

---
### Функции